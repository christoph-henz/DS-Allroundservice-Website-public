<?php
/**
 * Admin API Endpoint
 * Handles all admin panel requests
 */

// Prevent any output before JSON headers
error_reporting(E_ALL);
ini_set('display_errors', 0); // Don't display errors to browser

// Start session first - only if not already started
if (session_status() === PHP_SESSION_NONE) {
    session_start();
}

// Check if this is a file download request - handle BEFORE any headers are set
$action = $_GET['action'] ?? $_POST['action'] ?? '';
$isFileDownload = ($action === 'download-attachment');

error_log("🔍 Admin.php loaded - Action: $action, Is file download: " . ($isFileDownload ? 'YES' : 'NO'));

if (!$isFileDownload) {
    // Start output buffering to catch any accidental output (NOT for downloads!)
    ob_start();
    
    // Set JSON headers (NOT for downloads!)
    header('Content-Type: application/json; charset=utf-8');
    header('Access-Control-Allow-Origin: *');
    header('Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS');
    header('Access-Control-Allow-Headers: Content-Type, Authorization');
} else {
    error_log("📎 File download detected - Skipping JSON headers");
}

// Handle preflight requests
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(200);
    exit();
}

// Include the autoloader if available
if (file_exists(__DIR__ . '/../vendor/autoload.php')) {
    require_once __DIR__ . '/../vendor/autoload.php';
}

// Include the Page class for database inheritance
require_once __DIR__ . '/../src/Views/Page.php';
require_once __DIR__ . '/../src/Views/CookieHandler.php';

// Try to include EmailInbox only if IMAP is available and class not already loaded
if (extension_loaded('imap') && !class_exists('EmailInbox')) {
    try {
        require_once __DIR__ . '/../src/Utils/EmailInbox.php';
    } catch (Error $e) {
        error_log('Failed to load EmailInbox: ' . $e->getMessage());
    }
}

// Always include fallback for safety
if (!class_exists('EmailInboxFallback')) {
}

use DSAllround\Views\Page;
use DSAllround\Utils\PDFGenerator;
// EmailInbox is loaded conditionally below, not via use statement

class AdminAPI extends Page {
    
    private $db;
    private $debug = true; // Set to true for debugging
    
    /**
     * Get appropriate email inbox instance
     */
    private function getEmailInboxInstance() {
        // Check if email inbox is enabled in settings
        try {
            $stmt = $this->db->prepare("SELECT setting_value FROM settings WHERE setting_key = 'email_inbox_enabled'");
            $stmt->execute();
            $enabled = $stmt->fetchColumn();
            
            if (!$enabled || $enabled === '0') {
                error_log('📧 Email inbox disabled in settings - using fallback');
                return new EmailInboxFallback($this->db);
            }
        } catch (Exception $e) {
            error_log('⚠️ Could not check email_inbox_enabled setting: ' . $e->getMessage());
        }
        
        // Check IMAP availability and class existence
        if (extension_loaded('imap') && class_exists('EmailInbox')) {
            error_log('📧 Using IMAP EmailInbox');
            return new EmailInbox($this->db);
        } else {
            error_log('📧 IMAP not available - using fallback');
            return new EmailInboxFallback($this->db);
        }
    }
    
    public function __construct() {
        // Call parent constructor to get database connection
        parent::__construct();
        // Use the inherited database connection
        $this->db = $this->_database;
        
        // Initialize admin-specific tables
        $this->initializeAdminTables();
    }
    
    private function initializeAdminTables() {
        try {
            // Database connection is already set up by parent constructor
            
            // Ensure company settings exist in database
            $this->ensureCompanySettings();
            if ($this->isLocal) {
                // SQLite specific settings are already applied by parent
                $this->db->exec('PRAGMA foreign_keys = ON');
            }
            // Initialize admin-specific tables
            $this->initializeTables();
        } catch (\PDOException $e) {
            throw new Exception("Database initialization failed: " . $e->getMessage());
        }
    }
    
    private function addMissingColumns() {
        try {
            // Check which columns exist in service_pages table (MySQL syntax)
            $stmt = $this->db->query("SHOW COLUMNS FROM service_pages");
            $columns = $stmt->fetchAll(PDO::FETCH_ASSOC);
            $existingColumns = array_column($columns, 'Field'); // MySQL uses 'Field' not 'name'
            
            $columnsToAdd = [
                'features_subtitle' => 'ALTER TABLE service_pages ADD COLUMN features_subtitle TEXT',
                'process_subtitle' => 'ALTER TABLE service_pages ADD COLUMN process_subtitle TEXT',
                'pricing_subtitle' => 'ALTER TABLE service_pages ADD COLUMN pricing_subtitle TEXT',
                'faq_title' => 'ALTER TABLE service_pages ADD COLUMN faq_title TEXT',
                'faq_content' => 'ALTER TABLE service_pages ADD COLUMN faq_content TEXT'
            ];
            
            foreach ($columnsToAdd as $columnName => $sql) {
                if (!in_array($columnName, $existingColumns)) {
                    try {
                        $this->db->exec($sql);
                    } catch (\PDOException $e) {
                        // Still log actual errors, but not "column exists" errors
                        error_log("Error adding column $columnName: " . $e->getMessage());
                    }
                }
            }
        } catch (\PDOException $e) {
            // Table might not exist yet - that's okay
            error_log("Could not check service_pages columns: " . $e->getMessage());
        }
    }
    
    // Debug helper method
    private function debugLog($message) {
        if ($this->debug) {
            error_log("DEBUG: $message");
        }
    }
    
    // Helper method to execute prepared queries and return statement
    private function query($sql, $params = []) {
        try {
            $stmt = $this->db->prepare($sql);
            $stmt->execute($params);
            return $stmt;
        } catch (\PDOException $e) {
            throw new Exception("Query failed: " . $e->getMessage());
        }
    }
    
    private function initializeTables() {
        // Create services table if not exists
        $this->db->exec("
            CREATE TABLE IF NOT EXISTS services (
                id INT AUTO_INCREMENT PRIMARY KEY,
                name VARCHAR(200) NOT NULL,
                slug VARCHAR(200) NOT NULL UNIQUE,
                title VARCHAR(200),
                description TEXT,
                icon VARCHAR(100),
                color VARCHAR(7) DEFAULT '#007cba',
                sort_order INT DEFAULT 0,
                is_active TINYINT(1) DEFAULT 1,
                pricing_data TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
        ");
        
        // Add pricing_data column to existing services table if it doesn't exist
        try {
            $this->db->exec("ALTER TABLE services ADD COLUMN pricing_data TEXT");
        } catch (\PDOException $e) {
            // Column already exists or other error - ignore
        }
        
        // Create simplified questions table compatible with the API
        $this->db->exec("
            CREATE TABLE IF NOT EXISTS questions_simple (
                id INT AUTO_INCREMENT PRIMARY KEY,
                question_text TEXT NOT NULL,
                question_type VARCHAR(20) NOT NULL,
                is_required TINYINT(1) DEFAULT 0,
                placeholder_text TEXT,
                help_text TEXT,
                options TEXT,
                validation_rules TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
        ");
        
        // Create questionnaires table if not exists
        $this->db->exec("
            CREATE TABLE IF NOT EXISTS questionnaires (
                id INT AUTO_INCREMENT PRIMARY KEY,
                title VARCHAR(200) NOT NULL,
                description TEXT,
                service_types TEXT,
                service_id INT,
                status VARCHAR(20) DEFAULT 'draft',
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                FOREIGN KEY (service_id) REFERENCES services(id)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
        ");
        
        // Add service_id column if it doesn't exist (for existing databases)
        try {
            $this->db->exec("ALTER TABLE questionnaires ADD COLUMN service_id INT");
        } catch (\PDOException $e) {
            // Column already exists or other error - ignore
        }
        
        // Create questionnaire_questions junction table
        $this->db->exec("
            CREATE TABLE IF NOT EXISTS questionnaire_questions (
                id INT AUTO_INCREMENT PRIMARY KEY,
                questionnaire_id INT NOT NULL,
                question_id INT NOT NULL,
                sort_order INT DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (questionnaire_id) REFERENCES questionnaires(id) ON DELETE CASCADE,
                FOREIGN KEY (question_id) REFERENCES questions_simple(id) ON DELETE CASCADE
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
        ");
        
        // Create question_groups table if not exists
        $this->db->exec("
            CREATE TABLE IF NOT EXISTS question_groups (
                id INT AUTO_INCREMENT PRIMARY KEY,
                questionnaire_id INT NOT NULL,
                name VARCHAR(100) NOT NULL,
                description TEXT,
                sort_order INT DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                FOREIGN KEY (questionnaire_id) REFERENCES questionnaires(id) ON DELETE CASCADE
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
        ");
        
        // Create email_templates table if not exists
        $this->db->exec("
            CREATE TABLE IF NOT EXISTS email_templates (
                id INT AUTO_INCREMENT PRIMARY KEY,
                name VARCHAR(100) NOT NULL,
                subject VARCHAR(200) NOT NULL,
                content TEXT NOT NULL,
                template_type VARCHAR(50) DEFAULT 'general',
                is_active TINYINT(1) DEFAULT 1,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
        ");
        
        // Create service_pages table if not exists
        try {
            $this->db->exec("
                CREATE TABLE IF NOT EXISTS service_pages (
                    id INT AUTO_INCREMENT PRIMARY KEY,
                    service_id INT NOT NULL,
                    hero_title VARCHAR(200),
                    hero_subtitle TEXT,
                    intro_title VARCHAR(200),
                    intro_content TEXT,
                    features_title VARCHAR(200),
                    features_subtitle TEXT,
                    features_content TEXT,
                    process_title VARCHAR(200),
                    process_subtitle TEXT,
                    process_content TEXT,
                    pricing_title VARCHAR(200),
                    pricing_subtitle TEXT,
                    faq_title TEXT,
                    faq_content TEXT,
                    meta_title VARCHAR(200),
                    meta_description TEXT,
                    meta_keywords TEXT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    FOREIGN KEY(service_id) REFERENCES services(id) ON DELETE CASCADE
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
            ");
        } catch (\PDOException $e) {
            // Table might already exist with different schema - that's okay
            error_log("Service pages table creation note: " . $e->getMessage());
        }
        
        // Add missing columns to existing service_pages table if they don't exist
        $this->addMissingColumns();
        
        // Create images table if not exists
        $this->db->exec("
            CREATE TABLE IF NOT EXISTS images (
                id INT AUTO_INCREMENT PRIMARY KEY,
                name TEXT NOT NULL UNIQUE,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
        ");

        // Create settings table if not exists
        $this->db->exec("
            CREATE TABLE IF NOT EXISTS settings (
                id INT AUTO_INCREMENT PRIMARY KEY,
                setting_key VARCHAR(100) NOT NULL UNIQUE,
                setting_value TEXT,
                setting_type VARCHAR(20) DEFAULT 'string',
                description TEXT,
                is_public TINYINT(1) DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
        ");

        // Insert default settings if none exist
        $this->insertDefaultSettings();

        // Insert default services if none exist
        $serviceCount = $this->queryAll("SELECT COUNT(*) as count FROM services")[0]['count'] ?? 0;
        if ($serviceCount == 0) {
            $defaultServices = [
                ['Umzüge', 'umzuege', 'Professionelle Umzugsservice', 'Komplette Umzugsdienstleistungen für Privatpersonen und Unternehmen', 'truck', '#007cba', 1],
                ['Transport', 'transport', 'Transport & Logistik', 'Sichere Transportdienstleistungen für alle Arten von Gütern', 'shipping', '#28a745', 2],
                ['Entrümpelung', 'entruempelung', 'Entrümpelung & Entsorgung', 'Professionelle Entrümpelung von Wohnungen, Häusern und Gewerbeobjekten', 'trash', '#dc3545', 3],
                ['Auflösung', 'aufloesung', 'Haushaltsauflösung', 'Komplette Haushaltsauflösung mit fachgerechter Entsorgung', 'home', '#fd7e14', 4]
            ];
            
            foreach ($defaultServices as $service) {
                $this->execute(
                    "INSERT INTO services (name, slug, title, description, icon, color, sort_order) VALUES (?, ?, ?, ?, ?, ?, ?)",
                );
            }
        }
    }

    /**
     * Insert default settings if settings table is empty
     */
    private function insertDefaultSettings() {
        $settingsCount = $this->queryAll("SELECT COUNT(*) as count FROM settings")[0]['count'] ?? 0;
        if ($settingsCount == 0) {
            $defaultSettings = [
                // Public settings (is_public = 1)
                ['site_name', 'DS Allroundservice', 'string', 'Name der Website', 1],
                ['site_description', 'Ihr zuverlässiger Partner für Umzüge, Transport und Entrümpelung', 'string', 'Beschreibung der Website', 1],
                ['contact_email', 'info@ds-allroundservice.de', 'string', 'Kontakt E-Mail Adresse', 1],
                ['contact_phone', '+49 123 456789', 'string', 'Kontakt Telefonnummer', 1],
                ['contact_address', 'Musterstraße 123, 63741 Aschaffenburg', 'string', 'Geschäftsadresse', 1],
                ['business_hours', '{"monday": "8:00-18:00", "tuesday": "8:00-18:00", "wednesday": "8:00-18:00", "thursday": "8:00-18:00", "friday": "8:00-18:00", "saturday": "9:00-16:00", "sunday": "Geschlossen"}', 'json', 'Geschäftszeiten', 1],
                ['social_facebook', '', 'string', 'Facebook URL', 1],
                ['social_instagram', '', 'string', 'Instagram URL', 1],
                ['social_twitter', '', 'string', 'Twitter URL', 1],
                ['cookie_consent_required', '1', 'bool', 'Cookie Consent Banner anzeigen', 1],
                ['default_service_color', '#007cba', 'string', 'Standard Farbe für neue Services', 1],
                
                // Admin-only settings (is_public = 0)
                ['maintenance_mode', '0', 'bool', 'Wartungsmodus aktiviert', 0],
                ['google_analytics_id', '', 'string', 'Google Analytics Tracking ID', 0],
                ['max_file_upload_size', '10485760', 'int', 'Maximale Upload-Größe in Bytes (10MB)', 0],
                ['admin_items_per_page', '20', 'int', 'Anzahl Einträge pro Seite im Admin', 0],
                ['debug_mode', '0', 'bool', 'Debug-Modus aktiviert', 0],
                ['backup_frequency', 'weekly', 'string', 'Automatische Backup-Häufigkeit (daily, weekly, monthly)', 0],
                ['session_timeout', '7200', 'int', 'Session-Timeout in Sekunden (2 Stunden)', 0],
                ['admin_email_notifications', '1', 'bool', 'E-Mail-Benachrichtigungen für Admins', 0],
                ['system_log_level', 'error', 'string', 'System-Log-Level (debug, info, warning, error)', 0],
                ['api_rate_limit', '100', 'int', 'API Rate Limit pro Stunde', 0]
            ];
            
            foreach ($defaultSettings as $setting) {
                $this->execute(
                    "INSERT INTO settings (setting_key, setting_value, setting_type, description, is_public) VALUES (?, ?, ?, ?, ?)",
                    $setting
                );
            }
        }
    }

    // Helper method to execute prepared queries and return all rows as array
    private function queryAll($sql, $params = []) {
        try {
            $stmt = $this->db->prepare($sql);
            $stmt->execute($params);
            return $stmt->fetchAll();
        } catch (\PDOException $e) {
            throw new Exception("Query failed: " . $e->getMessage());
        }
    }
    
    // Helper method to execute without returning results  
    private function execute($sql, $params = []) {
        try {
            $stmt = $this->db->prepare($sql);
            return $stmt->execute($params);
        } catch (\PDOException $e) {
            throw new Exception("Execute failed: " . $e->getMessage());
        }
    }
    
    public function handleRequest() {
        try {
            // Debug logging for API calls
            error_log("Admin API called with REQUEST_METHOD: " . ($_SERVER['REQUEST_METHOD'] ?? 'UNKNOWN'));
            error_log("Admin API called with REQUEST_URI: " . ($_SERVER['REQUEST_URI'] ?? 'UNKNOWN'));
            error_log("Admin API called with GET params: " . print_r($_GET, true));
            
            // Get action from either URL parameter or JSON body
            $action = $_REQUEST['action'] ?? '';
            
            error_log("Admin API action: " . $action);
            
            // For POST requests, check if action is in JSON body
            if ($_SERVER['REQUEST_METHOD'] === 'POST' && empty($action)) {
                $input = json_decode(file_get_contents('php://input'), true);
                $action = $input['action'] ?? '';
            }
            
            // ========================================================================
            // SECURITY: Zentrale Authentifizierungs- und Autorisierungsprüfung
            // ========================================================================
            
            // Whitelist für Aktionen die OHNE Authentifizierung erlaubt sind
            // WICHTIG: Nur Permissions-Abfrage ist ohne Login erlaubt!
            $publicActions = [];
            
            // Prüfe ob Aktion öffentlich ist
            $isPublicAction = in_array($action, $publicActions);
            
            // Prüfe Authentifizierung für alle nicht-öffentlichen Aktionen
            if (!$isPublicAction) {
                if (!$this->isAuthenticated()) {
                    http_response_code(401);
                    error_log("🔒 Unauthorized access attempt to action: $action");
                    return $this->error('Nicht authentifiziert. Bitte melden Sie sich an.');
                }
                
                error_log("✅ User authenticated: " . ($_SESSION['username'] ?? 'unknown') . " (Role: " . ($_SESSION['role'] ?? 'unknown') . ")");
            }
            
            // CSRF-Token Validierung für alle schreibenden Operationen
            if (!$isPublicAction && in_array($_SERVER['REQUEST_METHOD'], ['POST', 'PUT', 'DELETE'])) {
                // Ausnahme für File Downloads (haben keine CSRF-Tokens)
                if ($action !== 'download-attachment') {
                    if (!$this->validateCSRFToken()) {
                        http_response_code(403);
                        error_log("🔒 CSRF token validation failed for action: $action");
                        return $this->error('Ungültiger CSRF-Token. Bitte laden Sie die Seite neu.');
                    }
                }
            }
            
            // Permission-basierte Zugriffskontrolle
            $requiredPermission = $this->getRequiredPermission($action);
            if ($requiredPermission && !$this->hasPermission($requiredPermission)) {
                http_response_code(403);
                error_log("🔒 Permission denied for action: $action (required: $requiredPermission)");
                return $this->error('Keine Berechtigung für diese Aktion.');
            }
            
            // Rate Limiting (Schutz vor Missbrauch)
            if (!$this->checkRateLimit($action)) {
                http_response_code(429);
                error_log("⚠️ Rate limit exceeded for action: $action");
                return $this->error('Zu viele Anfragen. Bitte warten Sie einen Moment.');
            }
            
            // ========================================================================
            // Action-Routing
            // ========================================================================
            
            switch ($action) {
                case 'dashboard':
                    return $this->getDashboardData();
                    
                case 'stats':
                    return $this->getStats();
                    
                case 'services':
                    return $this->getServices();
                    
                case 'service':
                    return $this->getService();
                    
                case 'service-list':
                    return $this->getServiceList();
                    
                case 'save-service':
                    return $this->saveService();
                    
                case 'delete-service':
                    return $this->deleteService();
                    
                case 'service-page':
                    return $this->getServicePage();
                    
                case 'save-service-page':
                    return $this->saveServicePage();
                    
                case 'service-page-content':
                    return $this->getServicePageContent();
                    
                case 'save-service-page-content':
                    return $this->saveServicePageContent();
                    
                case 'submissions':
                    return $this->getSubmissions();
                    
                case 'submission':
                    return $this->getSubmission();
                    
                case 'submission-emails':
                    return $this->getSubmissionEmails();
                    
                case 'exportPDF':
                    return $this->exportSubmissionPDF();
                    
                case 'submission-stats':
                    return $this->getSubmissionAnswerStats();
                    
                case 'update-submission-status':
                    return $this->updateSubmissionStatus();
                    
                case 'generate-offer':
                    return $this->generateOfferPDF();
                    
                case 'debug-vat':
                    // Debug VAT settings - return VAT setting info
                    return $this->getVATSetting();
                    
                case 'offers':
                    return $this->getOffers();
                    
                case 'offer-details':
                    return $this->getOfferDetails();
                    
                case 'submission-offers':
                    return $this->getSubmissionOffers();
                    
                case 'update-offer-status':
                    return $this->updateOfferStatus();
                    
                case 'archived-submissions':
                    return $this->getArchivedSubmissions();
                    
                case 'archive-stats':
                    return $this->getArchiveStats();
                    
                case 'restore-submission':
                    return $this->restoreSubmission();
                    
                case 'send-response-email':
                    return $this->sendResponseEmail();
                    
                case 'email-templates':
                    return $this->getEmailTemplates();
                    
                case 'email-template':
                    return $this->getEmailTemplate();
                    
                case 'save-email-template':
                    return $this->saveEmailTemplate();
                    
                case 'delete-email-template':
                    return $this->deleteEmailTemplate();
                    
                case 'preview-email-template':
                    return $this->previewEmailTemplate();
                    
                case 'send_test_email':
                    return $this->sendTestEmail();
                    
                case 'debug_variables':
                    return $this->debugVariables();
                    
                // Questionnaire Management
                case 'questionnaires':
                    return $this->getQuestionnaires();
                    
                case 'questionnaire':
                    return $this->getQuestionnaire();
                    
                case 'create-questionnaire':
                    return $this->createQuestionnaire();
                    
                case 'update-questionnaire':
                    return $this->updateQuestionnaire();
                    
                case 'delete-questionnaire':
                    return $this->deleteQuestionnaire();
                    
                case 'questionnaire-questions':
                    return $this->getQuestionnaireQuestions();
                    
                // Questions Management
                case 'questions':
                    return $this->getQuestions();
                    
                case 'question':
                    return $this->getQuestion();
                    
                case 'create-question':
                    return $this->createQuestion();
                    
                case 'update-question':
                    return $this->updateQuestion();
                    
                case 'delete-question':
                    return $this->deleteQuestion();
                    
                case 'add-question-to-questionnaire':
                    return $this->addQuestionToQuestionnaire();
                    
                case 'remove-question-from-questionnaire':
                    return $this->removeQuestionFromQuestionnaire();
                    
                case 'get-questionnaire-questions':
                    return $this->getQuestionnaireQuestions();
                    
                // Groups Management
                case 'questionnaire-groups':
                    return $this->getQuestionnaireGroups();
                    
                case 'create-group':
                    return $this->createGroup();
                    
                case 'update-group':
                    return $this->updateGroup();
                    
                case 'delete-group':
                    return $this->deleteGroup();
                    
                case 'move-question':
                    return $this->moveQuestion();
                    
                case 'move-question-to-group':
                    return $this->moveQuestionToGroup();
                    
                case 'reorder-questions':
                    return $this->reorderQuestions();
                    
                case 'reorder-groups':
                    return $this->reorderGroups();
                    
                case 'create-group-from-questions':
                    return $this->createGroupFromQuestions();
                    
                case 'remove-question-from-group':
                    return $this->removeQuestionFromGroup();
                    
                // Image Management
                case 'images':
                    return $this->getImages();
                    
                case 'upload-images':
                    return $this->uploadImages();
                    
                case 'delete-image':
                    return $this->deleteImage();
                    
                // Settings Management
                case 'settings':
                    return $this->getSettings();
                    
                case 'get-setting':
                    return $this->getSetting();
                    
                case 'get-settings':
                    return $this->getSettings();
                    
                case 'get-vat-setting':
                    return $this->getVATSetting();
                    
                case 'save-setting':
                    return $this->saveSetting();
                    
                case 'save-settings':
                    return $this->saveSettings();
                    
                // User Management
                case 'create-user':
                    return $this->createUser();
                    
                case 'update-user':
                    return $this->updateUser();
                    
                case 'reset-user-password':
                    return $this->resetUserPassword();
                    
                case 'toggle-user-status':
                    return $this->toggleUserStatus();
                    
                // E-Mail Management
                case 'inbox-emails':
                    return $this->getInboxEmails();
                    
                case 'email-details':
                    return $this->getEmailDetails();
                    
                case 'debug-email-structure':
                    return $this->debugEmailStructure();
                    
                case 'mark-email-read':
                    return $this->markEmailAsRead();
                    
                case 'mark-email-unread':
                    return $this->markEmailAsUnread();
                    
                case 'delete-email':
                    return $this->deleteEmail();
                    
                case 'download-attachment':
                    return $this->downloadAttachment();
                    
                case 'test-email-connection':
                    return $this->testEmailConnection();
                    
                case 'email-unread-count':
                    return $this->getEmailUnreadCount();
                    
                // Event Store Management
                case 'create-email-snapshot':
                    return $this->createEmailSnapshot();
                    
                case 'get-event-store-stats':
                    return $this->getEventStoreStats();
                    
                case 'cleanup-event-store':
                    return $this->cleanupEventStore();
                    
                case 'change-password':
                    return $this->changePassword();
                    
                // Logs Management (Admin only)
                case 'get-activity-logs':
                    return $this->getActivityLogs();
                    
                case 'get-sessions-logs':
                    return $this->getSessionsLogs();
                    
                case 'get-email-logs':
                    return $this->getEmailLogs();
                    
                case 'export-activity-logs':
                    return $this->exportActivityLogs();
                    
                case 'export-sessions-logs':
                    return $this->exportSessionsLogs();
                    
                case 'export-email-logs':
                    return $this->exportEmailLogs();
                    
                case 'terminate-session':
                    return $this->terminateSession();
                    
                case 'get-users-list':
                    return $this->getUsersList();
                    
                // Debug endpoint to check permissions
                case 'debug-permissions':
                    return $this->debugPermissions();
                    
                default:
                    return $this->error('Invalid action');
            }
        } catch (Exception $e) {
            return $this->error('Server error: ' . $e->getMessage());
        }
    }
    
    // ========================================================================
    // Security & Authentication Methods
    // ========================================================================
    
    /**
     * Prüft ob der aktuelle Benutzer authentifiziert ist
     */
    private function isAuthenticated() {
        // Session muss aktiv sein
        if (session_status() === PHP_SESSION_NONE) {
            session_start();
        }
        
        // Prüfe Session-Variablen
        if (!isset($_SESSION['authenticated']) || $_SESSION['authenticated'] !== true) {
            return false;
        }
        
        if (!isset($_SESSION['user_id']) || !isset($_SESSION['role'])) {
            return false;
        }
        
        // Optional: Prüfe Session-Token in Datenbank
        if (isset($_SESSION['session_token'])) {
            $stmt = $this->db->prepare("
                SELECT id FROM user_sessions 
                WHERE session_token = ? 
                AND is_active = 1 
                AND expires_at > datetime('now')
            ");
            $stmt->execute([$_SESSION['session_token']]);
            
            if (!$stmt->fetch()) {
                // Session in DB ungültig
                session_destroy();
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Validiert CSRF-Token
     */
    private function validateCSRFToken() {
        // CSRF-Token aus verschiedenen Quellen holen
        $headerToken = $_SERVER['HTTP_X_CSRF_TOKEN'] ?? '';
        $postToken = $_POST['csrf_token'] ?? '';
        $getToken = $_GET['csrf_token'] ?? '';
        
        // Session-Token
        $sessionToken = $_SESSION['csrf_token'] ?? '';
        
        // Kein Token in Session = kein Schutz möglich
        if (empty($sessionToken)) {
            error_log("⚠️ No CSRF token in session");
            return false;
        }
        
        // Prüfe ob einer der Tokens übereinstimmt
        $providedToken = $headerToken ?: ($postToken ?: $getToken);
        
        if (empty($providedToken)) {
            error_log("⚠️ No CSRF token provided in request");
            return false;
        }
        
        $isValid = hash_equals($sessionToken, $providedToken);
        
        if (!$isValid) {
            error_log("⚠️ CSRF token mismatch");
        }
        
        return $isValid;
    }
    
    /**
     * Generiert einen neuen CSRF-Token
     */
    private function generateCSRFToken() {
        $token = bin2hex(random_bytes(32));
        $_SESSION['csrf_token'] = $token;
        return $token;
    }
    
    /**
     * Gibt den benötigten Permission-String für eine Action zurück
     */
    private function getRequiredPermission($action) {
        // Permission-Mapping: action => required_permission
        $permissionMap = [
            // Dashboard
            'dashboard' => 'dashboard_view',
            'stats' => 'dashboard_view',
            
            // Services
            'services' => 'services_view',
            'service' => 'services_view',
            'service-list' => 'services_view',
            'save-service' => 'services_manage',
            'delete-service' => 'services_manage',
            
            // Service Pages
            'service-page' => 'services_view',
            'service-page-content' => 'services_view',
            'save-service-page' => 'services_manage',
            'save-service-page-content' => 'services_manage',
            
            // Submissions
            'submissions' => 'submissions_view',
            'submission' => 'submissions_view',
            'submission-emails' => 'submissions_view',
            'submission-stats' => 'submissions_view',
            'exportPDF' => 'submissions_view',
            'update-submission-status' => 'submissions_manage',
            'send-response-email' => 'submissions_manage',
            'generate-offer' => 'submissions_manage',
            
            // Offers
            'offers' => 'submissions_view',
            'offer-details' => 'submissions_view',
            'submission-offers' => 'submissions_view',
            'update-offer-status' => 'submissions_manage',
            
            // Archive
            'archived-submissions' => 'submissions_view',
            'archive-stats' => 'submissions_view',
            'restore-submission' => 'submissions_manage',
            
            // Email Templates
            'email-templates' => 'email_templates_view',
            'email-template' => 'email_templates_view',
            'preview-email-template' => 'email_templates_view',
            'save-email-template' => 'email_templates_manage',
            'delete-email-template' => 'email_templates_manage',
            'send_test_email' => 'email_templates_manage',
            'debug_variables' => 'email_templates_view',
            
            // Questionnaires
            'questionnaires' => 'questionnaires_view',
            'questionnaire' => 'questionnaires_view',
            'questionnaire-questions' => 'questionnaires_view',
            'create-questionnaire' => 'questionnaires_manage',
            'update-questionnaire' => 'questionnaires_manage',
            'delete-questionnaire' => 'questionnaires_manage',
            
            // Questions
            'questions' => 'questionnaires_view',
            'question' => 'questionnaires_view',
            'create-question' => 'questionnaires_manage',
            'update-question' => 'questionnaires_manage',
            'delete-question' => 'questionnaires_manage',
            'add-question-to-questionnaire' => 'questionnaires_manage',
            'remove-question-from-questionnaire' => 'questionnaires_manage',
            'get-questionnaire-questions' => 'questionnaires_view',
            
            // Groups
            'questionnaire-groups' => 'questionnaires_view',
            'create-group' => 'questionnaires_manage',
            'update-group' => 'questionnaires_manage',
            'delete-group' => 'questionnaires_manage',
            'move-question' => 'questionnaires_manage',
            'move-question-to-group' => 'questionnaires_manage',
            'reorder-questions' => 'questionnaires_manage',
            'reorder-groups' => 'questionnaires_manage',
            'create-group-from-questions' => 'questionnaires_manage',
            'remove-question-from-group' => 'questionnaires_manage',
            
            // Images/Media
            'images' => 'media_view',
            'upload-images' => 'media_manage',
            'delete-image' => 'media_manage',
            
            // Settings
            'settings' => 'settings_view',
            'get-setting' => 'settings_view',
            'get-settings' => 'settings_view',
            'get-vat-setting' => 'settings_view',
            'save-setting' => 'settings_manage',
            'save-settings' => 'settings_manage',
            'debug-vat' => 'settings_view',
            
            // User Management
            'create-user' => 'users_manage',
            'update-user' => 'users_manage',
            'reset-user-password' => 'users_manage',
            'toggle-user-status' => 'users_manage',
            'change-password' => null, // Eigenes Passwort ändern = kein Permission nötig
            
            // Email Inbox
            'inbox-emails' => 'email_inbox_view',
            'email-details' => 'email_inbox_view',
            'debug-email-structure' => 'email_inbox_view',
            'mark-email-read' => 'email_inbox_manage',
            'mark-email-unread' => 'email_inbox_manage',
            'delete-email' => 'email_inbox_manage',
            'download-attachment' => 'email_inbox_view',
            'test-email-connection' => 'email_inbox_view',
            'email-unread-count' => 'email_inbox_view',
            
            // Event Store
            'create-email-snapshot' => 'email_inbox_manage',
            'get-event-store-stats' => 'email_inbox_view',
            'cleanup-event-store' => 'email_inbox_manage',
            
            // Logs Management
            'get-activity-logs' => 'logs_view',
            'get-sessions-logs' => 'logs_view',
            'get-email-logs' => 'logs_view',
            'export-activity-logs' => 'logs_view',
            'export-sessions-logs' => 'logs_view',
            'export-email-logs' => 'logs_view',
            'terminate-session' => 'logs_view',
            'get-users-list' => 'logs_view', // Needed for user filter dropdown
        ];
        
        return $permissionMap[$action] ?? null;
    }
    
    /**
     * Rate Limiting - verhindert zu viele Anfragen
     */
    private function checkRateLimit($action) {
        // Rate Limiting nur für authentifizierte Benutzer
        if (!isset($_SESSION['user_id'])) {
            return true; // Öffentliche Actions haben eigenes Limit
        }
        
        $userId = $_SESSION['user_id'];
        $now = time();
        
        // Initialisiere Rate Limit Array
        if (!isset($_SESSION['rate_limit'])) {
            $_SESSION['rate_limit'] = [];
        }
        
        // Limit pro Minute: 120 Requests
        $limitPerMinute = 120;
        $windowSeconds = 60;
        
        // Key für diese Action
        $key = $action . '_' . $userId;
        
        // Hole oder initialisiere Daten für diesen Key
        if (!isset($_SESSION['rate_limit'][$key])) {
            $_SESSION['rate_limit'][$key] = [
                'count' => 0,
                'reset' => $now + $windowSeconds
            ];
        }
        
        $limit = &$_SESSION['rate_limit'][$key];
        
        // Prüfe ob Window abgelaufen ist
        if ($now > $limit['reset']) {
            $limit['count'] = 0;
            $limit['reset'] = $now + $windowSeconds;
        }
        
        // Prüfe ob Limit erreicht
        if ($limit['count'] >= $limitPerMinute) {
            error_log("⚠️ Rate limit exceeded for user $userId, action $action");
            return false;
        }
        
        // Erhöhe Counter
        $limit['count']++;
        
        return true;
    }
    
    // ========================================================================
    // Dashboard Methods
    // ========================================================================
    
    private function getDashboardData() {
        $stats = $this->getStats()['stats'];
        $recentSubmissions = $this->getRecentSubmissions();
        $serviceStats = $this->getServiceStats();
        
        return $this->success([
            'stats' => $stats,
            'recentSubmissions' => $recentSubmissions,
            'serviceStats' => $serviceStats
        ]);
    }
    
    private function getStats() {
        try {
            // Today's submissions
            $todaySubmissions = $this->queryAll(
                "SELECT COUNT(*) as count FROM questionnaire_submissions 
                 WHERE DATE(submitted_at) = DATE('now')"
            )[0]['count'] ?? 0;
            
            // Active services
            $activeServices = $this->queryAll(
                "SELECT COUNT(*) as count FROM services WHERE is_active = 1"
            )[0]['count'] ?? 0;
            
            // Monthly submissions
            $monthlySubmissions = $this->queryAll(
                "SELECT COUNT(*) as count FROM questionnaire_submissions 
                 WHERE strftime('%Y-%m', submitted_at) = strftime('%Y-%m', 'now')"
            )[0]['count'] ?? 0;
            
            // Conversion rate (placeholder calculation)
            $conversionRate = $monthlySubmissions > 0 ? 
                min(round(($todaySubmissions / max($monthlySubmissions, 1)) * 100, 1), 100) : 0;
            
            return $this->success([
                'stats' => [
                    'todaySubmissions' => $todaySubmissions,
                    'activeServices' => $activeServices,
                    'monthlySubmissions' => $monthlySubmissions,
                    'conversionRate' => $conversionRate
                ]
            ]);
        } catch (Exception $e) {
            return $this->error('Error getting stats: ' . $e->getMessage());
        }
    }
    
    private function getRecentSubmissions() {
        try {
            return $this->queryAll(
                "SELECT qs.*, s.name as service_name 
                 FROM questionnaire_submissions qs
                 JOIN services s ON qs.service_id = s.id
                 ORDER BY qs.submitted_at DESC 
                 LIMIT 10"
            );
        } catch (Exception $e) {
            // If tables don't exist, return empty array
            return [];
        }
    }
    
    private function getServiceStats() {
        try {
            return $this->queryAll(
                "SELECT s.name, COUNT(qs.id) as submissions
                 FROM services s
                 LEFT JOIN questionnaire_submissions qs ON s.id = qs.service_id
                 WHERE s.is_active = 1
                 GROUP BY s.id, s.name
                 ORDER BY submissions DESC"
            );
        } catch (Exception $e) {
            // If tables don't exist, return empty array
            return [];
        }
    }
    
    // ========================================================================
    // Service Methods
    // ========================================================================
    
    private function getServices() {
        try {
            $services = $this->queryAll(
                "SELECT s.*, COUNT(qs.id) as submission_count
                 FROM services s
                 LEFT JOIN questionnaire_submissions qs ON s.id = qs.service_id
                 GROUP BY s.id
                 ORDER BY s.sort_order ASC, s.name ASC"
            );
            
            return $this->success(['services' => $services]);
        } catch (Exception $e) {
            return $this->error('Error getting services: ' . $e->getMessage());
        }
    }
    
    private function getService() {
        $id = $_GET['id'] ?? null;
        if (!$id) {
            return $this->error('Service ID required');
        }
        
        try {
            $service = $this->queryAll(
                "SELECT * FROM services WHERE id = ?", 
                [$id]
            )[0] ?? null;
            
            if (!$service) {
                return $this->error('Service not found');
            }
            
            return $this->success(['service' => $service]);
        } catch (Exception $e) {
            return $this->error('Error getting service: ' . $e->getMessage());
        }
    }
    
    private function getServiceList() {
        try {
            $services = $this->queryAll(
                "SELECT id, name, slug FROM services 
                 WHERE is_active = 1 
                 ORDER BY sort_order ASC, name ASC"
            );
            
            return $this->success(['services' => $services]);
        } catch (Exception $e) {
            return $this->error('Error getting service list: ' . $e->getMessage());
        }
    }
    
    private function saveService() {
        $this->debugLog("saveService() called");
        $this->debugLog("POST data: " . print_r($_POST, true));
        
        $data = [
            'name' => $_POST['name'] ?? '',
            'slug' => $_POST['slug'] ?? '',
            'title' => $_POST['title'] ?? '',
            'description' => $_POST['description'] ?? '',
            'icon' => $_POST['icon'] ?? '',
            'color' => $_POST['color'] ?? '#007cba',
            'sort_order' => (int)($_POST['sort_order'] ?? 0),
            'is_active' => (int)($_POST['is_active'] ?? 1),
            'pricing_data' => $_POST['pricing_data'] ?? null
        ];
        
        $this->debugLog("Processed data: " . print_r($data, true));
        
        // Validation
        if (empty($data['name']) || empty($data['slug'])) {
            error_log("DEBUG: Validation failed - name or slug empty");
            return $this->error('Name und Slug sind erforderlich');
        }
        
        // Check for existing service with same slug
        $id = $_POST['id'] ?? null;
        if ($id) {
            // When updating, check if slug exists in OTHER services
            $existing = $this->queryAll("SELECT id FROM services WHERE slug = ? AND id != ?", [$data['slug'], $id]);
            if (!empty($existing)) {
                error_log("DEBUG: Another service with slug '{$data['slug']}' already exists (current ID: $id)");
                return $this->error("Ein anderer Service mit dem Slug '{$data['slug']}' existiert bereits. Bitte wählen Sie einen anderen Slug.");
            }
        } else {
            // When creating new, check if slug exists at all
            $existing = $this->queryAll("SELECT id FROM services WHERE slug = ?", [$data['slug']]);
            if (!empty($existing)) {
                error_log("DEBUG: Service with slug '{$data['slug']}' already exists");
                return $this->error("Ein Service mit dem Slug '{$data['slug']}' existiert bereits. Bitte wählen Sie einen anderen Slug.");
            }
        }
        
        try {
            $id = $_POST['id'] ?? null;
            error_log("DEBUG: Service ID: " . ($id ? $id : 'new'));
            
            if ($id) {
                // Update existing service
                error_log("DEBUG: Updating existing service with ID: $id");
                $result = $this->execute(
                    "UPDATE services SET 
                     name = ?, slug = ?, title = ?, description = ?, 
                     icon = ?, color = ?, sort_order = ?, is_active = ?, pricing_data = ?,
                     updated_at = CURRENT_TIMESTAMP
                     WHERE id = ?",
                    [
                        $data['name'], $data['slug'], $data['title'], $data['description'],
                        $data['icon'], $data['color'], $data['sort_order'], $data['is_active'], 
                        $data['pricing_data'], $id
                    ]
                );
                
                error_log("DEBUG: Update result: " . ($result ? 'success' : 'failed'));
                return $this->success(['message' => 'Service erfolgreich aktualisiert', 'id' => $id]);
            } else {
                // Create new service
                error_log("DEBUG: Creating new service");
                $result = $this->execute(
                    "INSERT INTO services (name, slug, title, description, icon, color, sort_order, is_active, pricing_data)
                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                    [
                        $data['name'], $data['slug'], $data['title'], $data['description'],
                        $data['icon'], $data['color'], $data['sort_order'], $data['is_active'], $data['pricing_data']
                    ]
                );
                
                $newId = $this->db->lastInsertId();
                error_log("DEBUG: New service created with ID: $newId");
                return $this->success(['message' => 'Service erfolgreich erstellt', 'id' => $newId]);
            }
        } catch (Exception $e) {
            error_log("DEBUG: Exception occurred: " . $e->getMessage());
            
            // Check for specific constraint violations
            if (strpos($e->getMessage(), 'UNIQUE constraint failed: services.slug') !== false) {
                return $this->error('Ein Service mit diesem Slug existiert bereits. Bitte wählen Sie einen anderen Slug.');
            }
            
            if (strpos($e->getMessage(), 'UNIQUE constraint failed: services.name') !== false) {
                return $this->error('Ein Service mit diesem Namen existiert bereits. Bitte wählen Sie einen anderen Namen.');
            }
            
            return $this->error('Fehler beim Speichern: ' . $e->getMessage());
        }
    }
    
    private function deleteService() {
        $input = json_decode(file_get_contents('php://input'), true);
        $id = $input['id'] ?? null;
        
        if (!$id) {
            return $this->error('Service ID required');
        }
        
        try {
            $this->execute("DELETE FROM services WHERE id = ?", [$id]);
            return $this->success(['message' => 'Service erfolgreich gelöscht']);
        } catch (Exception $e) {
            return $this->error('Error deleting service: ' . $e->getMessage());
        }
    }
    
    // ========================================================================
    // Service Page Methods
    // ========================================================================
    
    private function getServicePage() {
        $slug = $_GET['slug'] ?? null;
        if (!$slug) {
            return $this->error('Service slug required');
        }
        
        try {
            // Debug: Log the slug being searched
            error_log("Looking for service with slug: " . $slug);
            
            $service = $this->queryAll(
                "SELECT * FROM services WHERE slug = ?", 
                [$slug]
            )[0] ?? null;
            
            if (!$service) {
                // Debug: Log available services
                $allServices = $this->queryAll("SELECT slug FROM services");
                error_log("Available services: " . print_r(array_column($allServices, 'slug'), true));
                return $this->error('Service not found: ' . $slug);
            }
            
            error_log("Found service: " . $service['name']);
            
            $pageData = $this->queryAll(
                "SELECT * FROM service_pages WHERE service_id = ?", 
                [$service['id']]
            )[0] ?? [];
            
            // If no page data exists, create default data
            if (empty($pageData)) {
                error_log("No page data found for service_id: " . $service['id'] . ", creating default");
                $pageData = [
                    'hero_title' => $service['name'] . ' - Ihr professioneller Partner',
                    'hero_subtitle' => 'Zuverlässige und professionelle ' . strtolower($service['name']) . ' zu fairen Preisen',
                    'hero_cta_text' => 'Jetzt Angebot anfordern',
                    'intro_title' => 'Warum ' . $service['name'] . ' von DS Allroundservice?',
                    'intro_content' => '<p>Mit jahrelanger Erfahrung bieten wir Ihnen professionelle ' . strtolower($service['name']) . ' zu fairen Preisen.</p>',
                    'seo_title' => $service['name'] . ' | DS Allroundservice',
                    'seo_description' => 'Professionelle ' . strtolower($service['name']) . ' von DS Allroundservice. ✓ Erfahren ✓ Zuverlässig ✓ Faire Preise'
                ];
            }
            
            return $this->success(['pageData' => $pageData, 'service' => $service]);
        } catch (Exception $e) {
            error_log("Error in getServicePage: " . $e->getMessage());
            return $this->error('Error getting service page: ' . $e->getMessage());
        }
    }
    
    private function saveServicePage() {
        $serviceSlug = $_POST['service_slug'] ?? '';
        
        if (!$serviceSlug) {
            return $this->error('Service slug required');
        }
        
        try {
            // Get service ID
            $service = $this->queryAll(
                "SELECT id FROM services WHERE slug = ?", 
                [$serviceSlug]
            )[0] ?? null;
            
            if (!$service) {
                return $this->error('Service not found');
            }
            
            $serviceId = $service['id'];
            
            // Check if service page exists
            $existingPage = $this->queryAll(
                "SELECT id FROM service_pages WHERE service_id = ?", 
                [$serviceId]
            )[0] ?? null;
            
            $data = [
                'hero_title' => $_POST['hero_title'] ?? '',
                'hero_subtitle' => $_POST['hero_subtitle'] ?? '',
                'hero_image' => $_POST['hero_image'] ?? '',
                'hero_cta_text' => $_POST['hero_cta_text'] ?? '',
                'intro_title' => $_POST['intro_title'] ?? '',
                'intro_content' => $_POST['intro_content'] ?? '',
                'seo_title' => $_POST['seo_title'] ?? '',
                'seo_description' => $_POST['seo_description'] ?? ''
            ];
            
            if ($existingPage) {
                // Update existing page
                $this->execute(
                    "UPDATE service_pages SET 
                     hero_title = ?, hero_subtitle = ?, hero_image = ?, hero_cta_text = ?,
                     intro_title = ?, intro_content = ?, seo_title = ?, seo_description = ?,
                     updated_at = CURRENT_TIMESTAMP
                     WHERE service_id = ?",
                    [
                        $data['hero_title'], $data['hero_subtitle'], $data['hero_image'], $data['hero_cta_text'],
                        $data['intro_title'], $data['intro_content'], $data['seo_title'], $data['seo_description'],
                        $serviceId
                    ]
                );
            } else {
                // Create new page
                $this->execute(
                    "INSERT INTO service_pages 
                     (service_id, hero_title, hero_subtitle, hero_image, hero_cta_text,
                      intro_title, intro_content, seo_title, seo_description)
                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                    [
                        $serviceId,
                        $data['hero_title'], $data['hero_subtitle'], $data['hero_image'], $data['hero_cta_text'],
                        $data['intro_title'], $data['intro_content'], $data['seo_title'], $data['seo_description']
                    ]
                );
            }
            
            return $this->success(['message' => 'Seiteninhalte erfolgreich gespeichert']);
        } catch (Exception $e) {
            return $this->error('Error saving service page: ' . $e->getMessage());
        }
    }
    
    // ========================================================================
    // Submission Methods
    // ========================================================================
    
    private function getSubmissions() {
        try {
            $page = (int)($_GET['page'] ?? 1);
            $limit = (int)($_GET['limit'] ?? 50);
            $offset = ($page - 1) * $limit;
            
            // Filter logic:
            // - Show all submissions ≤ 30 days old
            // - Show older submissions (> 30 days) only if status ≠ 'abgeschlossen'
            $cutoffDate = date('Y-m-d H:i:s', strtotime('-30 days'));
            
            $submissions = $this->queryAll(
                "SELECT qs.*, s.name as service_name
                 FROM questionnaire_submissions qs
                 JOIN services s ON qs.service_id = s.id
                 WHERE (
                    qs.submitted_at >= ? 
                    OR (qs.submitted_at < ? AND qs.status != 'abgeschlossen')
                 )
                 ORDER BY qs.submitted_at DESC
                 LIMIT ? OFFSET ?",
                [$cutoffDate, $cutoffDate, $limit, $offset]
            );
            
            $total = $this->queryAll(
                "SELECT COUNT(*) as count 
                 FROM questionnaire_submissions qs
                 WHERE (
                    qs.submitted_at >= ? 
                    OR (qs.submitted_at < ? AND qs.status != 'abgeschlossen')
                 )",
                [$cutoffDate, $cutoffDate]
            )[0]['count'];
            
            return $this->success([
                'submissions' => $submissions,
                'pagination' => [
                    'page' => $page,
                    'limit' => $limit,
                    'total' => $total,
                    'pages' => ceil($total / $limit)
                ],
                'filter_info' => [
                    'cutoff_date' => $cutoffDate,
                    'description' => 'Zeigt Anfragen ≤30 Tage oder ältere mit Status ≠ abgeschlossen'
                ]
            ]);
        } catch (Exception $e) {
            return $this->error('Error getting submissions: ' . $e->getMessage());
        }
    }
    
    private function getSubmission() {
        $id = $_GET['id'] ?? null;
        if (!$id) {
            return $this->error('Submission ID required');
        }
        
        try {
            $submission = $this->queryAll(
                "SELECT qs.*, s.name as service_name
                 FROM questionnaire_submissions qs
                 JOIN services s ON qs.service_id = s.id
                 WHERE qs.id = ?",
                [$id]
            )[0] ?? null;
            
            if (!$submission) {
                return $this->error('Submission not found');
            }
            
            // Parse form_data JSON to extract answers
            $answers = [];
            if (!empty($submission['form_data'])) {
                $formData = json_decode($submission['form_data'], true);
                if (isset($formData['answers']) && is_array($formData['answers'])) {
                    $answers = $formData['answers'];
                }
            }
            
            return $this->success([
                'submission' => $submission,
                'answers' => $answers
            ]);
        } catch (Exception $e) {
            return $this->error('Error getting submission: ' . $e->getMessage());
        }
    }
    
    private function getSubmissionEmails() {
        $submissionId = $_GET['id'] ?? null;
        if (!$submissionId) {
            return $this->error('Submission ID required');
        }
        
        try {
            // Get submission data with contact information
            $submission = $this->queryAll(
                "SELECT qs.*, s.name as service_name
                 FROM questionnaire_submissions qs
                 JOIN services s ON qs.service_id = s.id
                 WHERE qs.id = ?",
                [$submissionId]
            )[0] ?? null;
            
            if (!$submission) {
                return $this->error('Submission not found');
            }
            
            // Parse form_data to extract contact email
            $contactEmail = null;
            if (!empty($submission['form_data'])) {
                $formData = json_decode($submission['form_data'], true);
                if (isset($formData['answers']) && is_array($formData['answers'])) {
                    $contactData = $this->extractContactDataFromAnswers($formData['answers']);
                    $contactEmail = $contactData['email'];
                }
            }
            
            if (!$contactEmail) {
                return $this->success([
                    'emails' => [],
                    'message' => 'Keine Kontakt-E-Mail gefunden'
                ]);
            }
            
            // Get submission date and find next submission from same contact
            $submissionDate = $submission['submitted_at'];
            $nextSubmissionDate = null;
            
            // Find next submission from same contact email
            $nextSubmission = $this->queryAll(
                "SELECT submitted_at FROM questionnaire_submissions 
                 WHERE form_data LIKE ? 
                 AND submitted_at > ? 
                 ORDER BY submitted_at ASC 
                 LIMIT 1",
                ['%' . $contactEmail . '%', $submissionDate]
            );

            if (!empty($nextSubmission)) {
                $nextSubmissionDate = $nextSubmission[0]['submitted_at'];
            } else {
                // If no next submission found, extend the search window to 30 days after submission
                $extendedDate = date('Y-m-d H:i:s', strtotime($submissionDate . ' + 30 days'));
                $nextSubmissionDate = $extendedDate;
            }            // Get company email from settings for filtering
            $companyEmailSetting = $this->queryAll(
                "SELECT setting_value FROM settings WHERE setting_key = 'email_username'",
                []
            );
            $companyEmail = !empty($companyEmailSetting) ? $companyEmailSetting[0]['setting_value'] : '';
            
            // Load emails using Event Store if available
            $emails = $this->getEmailsForSubmission($contactEmail, $companyEmail, $submissionDate, $nextSubmissionDate);
            
            return $this->success([
                'emails' => $emails,
                'contact_email' => $contactEmail,
                'submission_date' => $submissionDate,
                'next_submission_date' => $nextSubmissionDate,
                'company_email' => $companyEmail
            ]);
            
        } catch (Exception $e) {
            return $this->error('Error getting submission emails: ' . $e->getMessage());
        }
    }
    
    /**
     * Get emails for a specific submission within the relevant time range
     */
    private function getEmailsForSubmission($contactEmail, $companyEmail, $submissionDate, $nextSubmissionDate = null) {
        $emails = [];
        
        try {
            // Use EmailInbox with Event Store if available
            $emailInbox = $this->getEmailInboxInstance();
            if (!$emailInbox) {
                error_log("❌ EmailInbox instance not available");
                return [];
            }
            
            // Load all emails using Event Store for efficiency
            $allEmails = $emailInbox->getEmailsWithEventSourcing(1000); // Load more emails for filtering
            
            // Filter emails based on criteria
            $filteredEmails = [];
            $submissionTimestamp = strtotime($submissionDate);
            $nextSubmissionTimestamp = $nextSubmissionDate ? strtotime($nextSubmissionDate) : time();
            
            foreach ($allEmails as $email) {
                // Check if email is from the contact email to company email
                $emailTimestamp = isset($email['date_timestamp']) ? $email['date_timestamp'] : strtotime($email['date']);
                
                // Check if email is within time range (after submission, before next submission)
                if ($emailTimestamp >= $submissionTimestamp && $emailTimestamp <= $nextSubmissionTimestamp) {
                    
                    // Check if email is between contact and company
                    $fromEmail = $this->extractEmailFromHeader($email['from'] ?? '');
                    $toEmail = $this->extractEmailFromHeader($email['to'] ?? '');
                    
                    // Only emails that are FROM contact TO company OR FROM company TO contact
                    $isFromContact = stripos($fromEmail, $contactEmail) !== false;
                    $isToContact = stripos($toEmail, $contactEmail) !== false;
                    $isFromCompany = stripos($fromEmail, $companyEmail) !== false;
                    $isToCompany = stripos($toEmail, $companyEmail) !== false;
                    
                    // Only relevant correspondence between contact and company
                    if (($isFromContact && $isToCompany) || ($isFromCompany && $isToContact)) {
                        
                        // Clean and prepare email data for frontend
                        $filteredEmails[] = [
                            'uid' => $email['uid'] ?? '',
                            'subject' => $email['subject'] ?? 'Kein Betreff',
                            'from' => $email['from'] ?? '',
                            'to' => $email['to'] ?? '',
                            'date' => $email['date'] ?? '',
                            'date_formatted' => date('d.m.Y H:i', $emailTimestamp),
                            'body_preview' => $email['body_preview'] ?? '',
                            'seen' => $email['seen'] ?? false,
                            'flagged' => $email['flagged'] ?? false,
                            'has_attachments' => $email['has_attachments'] ?? false,
                            'attachment_count' => $email['attachment_count'] ?? 0
                        ];
                    }
                }
            }
            
            // Sort by date (newest first)
            usort($filteredEmails, function($a, $b) {
                return strtotime($b['date']) - strtotime($a['date']);
            });
            
            return $filteredEmails;
            
        } catch (Exception $e) {
            error_log("Error filtering emails for submission: " . $e->getMessage());
            return [];
        }
    }
    
    /**
     * Extract email address from email header string
     */
    private function extractEmailFromHeader($header) {
        if (empty($header)) {
            return '';
        }
        
        // Handle array format with object structure
        if (is_array($header)) {
            if (count($header) === 0) {
                return '';
            }
            
            // Get first element
            $headerItem = $header[0];
            
            // Check if it's an object/array with email field
            if (is_array($headerItem) && isset($headerItem['email'])) {
                return strtolower(trim($headerItem['email']));
            }
            
            // If it's just a string, use it
            if (is_string($headerItem)) {
                $header = $headerItem;
            } else {
                return '';
            }
        }
        
        // Convert to string if it's not already
        $header = (string) $header;
        
        // Extract email from "Name <email@domain.com>" format
        if (preg_match('/<([^>]+)>/', $header, $matches)) {
            return strtolower(trim($matches[1]));
        }
        
        // Return as-is if it looks like a simple email
        if (strpos($header, '@') !== false) {
            return strtolower(trim($header));
        }
        
        return '';
    }
    
    private function exportSubmissionPDF() {
        $id = $_GET['id'] ?? null;
        if (!$id) {
            return $this->error('Submission ID required');
        }
        
        try {
            // Get submission data
            $submission = $this->queryAll(
                "SELECT qs.*, s.name as service_name, s.slug as service_slug
                 FROM questionnaire_submissions qs
                 JOIN services s ON qs.service_id = s.id
                 WHERE qs.id = ?",
                [$id]
            )[0] ?? null;
            
            if (!$submission) {
                return $this->error('Submission not found');
            }
            
            // Parse form_data JSON to get the original submission data
            $formData = json_decode($submission['form_data'], true) ?? [];
            
            // Get service data
            $service = [
                'id' => $submission['service_id'],
                'name' => $submission['service_name'],
                'slug' => $submission['service_slug']
            ];
            
            // Determine if this is production environment
            $isProduction = !$this->isLocal;
            
            // Create PDF using the same logic as the submission handler
            $pdfGenerator = new PDFGenerator($formData, $service, $submission['reference'], $isProduction);
            
            // Check if we want to download or just generate
            $download = $_GET['download'] ?? 'true';
            
            if ($download === 'true') {
                // Generate and output PDF for download
                $pdfContent = $pdfGenerator->generatePDF();
                
                // Create a meaningful filename
                $filename = 'Anfrage_' . $submission['reference'] . '_' . 
                           preg_replace('/[^a-zA-Z0-9_-]/', '_', $submission['service_name']) . '.pdf';
                
                // Set headers for PDF download
                header('Content-Type: application/pdf');
                header('Content-Disposition: attachment; filename="' . $filename . '"');
                header('Content-Length: ' . strlen($pdfContent));
                header('Cache-Control: private, max-age=0, must-revalidate');
                header('Pragma: public');
                
                // Clear any previous output and JSON headers
                if (ob_get_level()) {
                    ob_end_clean();
                }
                echo $pdfContent;
                exit;
            } else {
                // Save PDF and return file path
                $pdfResult = $pdfGenerator->savePDF();
                
                if ($pdfResult['success']) {
                    // Update submission with PDF path
                    $stmt = $this->db->prepare(
                        "UPDATE questionnaire_submissions 
                         SET pdf_generated = 1, pdf_path = ?, processed_at = datetime('now')
                         WHERE id = ?"
                    );
                    $stmt->execute([$pdfResult['filepath'], $id]);
                    
                    return $this->success([
                        'pdf_generated' => true,
                        'pdf_path' => $pdfResult['filepath'],
                        'pdf_url' => $pdfResult['url'] ?? null,
                        'message' => 'PDF erfolgreich generiert'
                    ]);
                } else {
                    return $this->error('PDF generation failed: ' . ($pdfResult['error'] ?? 'Unknown error'));
                }
            }
            
        } catch (Exception $e) {
            return $this->error('Error exporting PDF: ' . $e->getMessage());
        }
    }

    private function getSubmissionAnswerStats() {
        $id = $_GET['id'] ?? null;
        if (!$id) {
            return $this->error('Submission ID required');
        }
        
        try {
            $submission = $this->queryAll(
                "SELECT qs.*, s.name as service_name
                 FROM questionnaire_submissions qs
                 JOIN services s ON qs.service_id = s.id
                 WHERE qs.id = ?",
                [$id]
            )[0] ?? null;
            
            if (!$submission) {
                return $this->error('Submission not found');
            }
            
            // Parse form_data JSON
            $formData = json_decode($submission['form_data'], true) ?? [];
            $answers = $formData['answers'] ?? [];
            
            // Load questionnaire for this service
            $questionnairePath = __DIR__ . '/../public/assets/questionnaires/' . $submission['service_id'] . '.json';
            $totalQuestions = 0;
            $questionPreviews = [];
            
            if (file_exists($questionnairePath)) {
                $questionnaire = json_decode(file_get_contents($questionnairePath), true);
                if (isset($questionnaire['questions'])) {
                    $totalQuestions = count($questionnaire['questions']);
                    
                    // Create question previews
                    foreach ($questionnaire['questions'] as $question) {
                        $qId = $question['id'];
                        $answer = $answers[$qId] ?? null;
                        
                        // Check if answer is valid
                        $answered = false;
                        if ($answer !== null && $answer !== '') {
                            if (is_string($answer)) {
                                $answered = !empty(trim($answer));
                            } else if (is_array($answer)) {
                                $answered = count($answer) > 0;
                            } else {
                                $answered = true; // For numbers, booleans, etc.
                            }
                        }
                        
                        $questionPreviews[$qId] = [
                            'text' => $question['text'],
                            'type' => $question['type'],
                            'answered' => $answered,
                            'answer' => $answer,
                            'preview' => $answered ? $this->generateAnswerPreview($answer, $question['type']) : 'Nicht beantwortet'
                        ];
                    }
                }
            }
            
            $answeredCount = count(array_filter($answers, function($answer) {
                if (empty($answer)) return false;
                if (is_string($answer)) {
                    return !empty(trim($answer));
                }
                if (is_array($answer)) {
                    return count($answer) > 0;
                }
                return true; // For numbers, booleans, etc.
            }));
            
            $completionPercentage = $totalQuestions > 0 ? round(($answeredCount / $totalQuestions) * 100) : 0;
            
            // Extract contact data from answers
            $contactData = $this->extractContactDataFromAnswers($answers);
            
            // Enhance submission data with extracted contact info
            $enhancedSubmission = $submission;
            if ($contactData['name']) {
                $enhancedSubmission['extracted_name'] = $contactData['name'];
            }
            if ($contactData['email']) {
                $enhancedSubmission['extracted_email'] = $contactData['email'];
            }
            if ($contactData['phone']) {
                $enhancedSubmission['extracted_phone'] = $contactData['phone'];
            }
            
            return $this->success([
                'total_questions' => $totalQuestions,
                'answered_count' => $answeredCount,
                'completion_percentage' => $completionPercentage,
                'question_previews' => $questionPreviews,
                'submission' => $enhancedSubmission,
                'contact_data' => $contactData
            ]);
            
        } catch (Exception $e) {
            return $this->error('Failed to get answer stats: ' . $e->getMessage());
        }
    }
    
    private function generateAnswerPreview($answer, $type) {
        if (empty($answer)) return 'Nicht beantwortet';
        
        switch ($type) {
            case 'text':
            case 'textarea':
                return strlen($answer) > 50 ? substr($answer, 0, 47) . '...' : $answer;
            case 'number':
                return $answer;
            case 'select':
            case 'radio':
                return $answer;
            case 'checkbox':
                if (is_array($answer)) {
                    return implode(', ', array_slice($answer, 0, 3)) . (count($answer) > 3 ? ' +' . (count($answer) - 3) . ' weitere' : '');
                }
                return $answer;
            case 'date':
                return date('d.m.Y', strtotime($answer));
            default:
                return $answer;
        }
    }
    
    private function extractContactDataFromAnswers($answers) {
        $contactData = [
            'name' => null,
            'email' => null,
            'phone' => null
        ];
        
        // Check if answers is in the new format (array with answer_text)
        if (is_array($answers) && isset($answers[0]) && is_array($answers[0])) {
            // New format: array of objects with answer_text
            foreach ($answers as $answer) {
                if (!is_array($answer)) continue;
                if (!isset($answer['question_text']) || !isset($answer['answer_text'])) continue;
                if ($answer['answer_text'] === null || $answer['answer_text'] === '') continue;
                if (!is_string($answer['question_text']) || !is_string($answer['answer_text'])) continue;
                
                $questionText = strtolower($answer['question_text']);
                $answerText = trim($answer['answer_text']);
                
                if (empty($answerText)) continue;
                
                // Extract name
                if (strpos($questionText, 'vor-') !== false && strpos($questionText, 'nachname') !== false) {
                    $contactData['name'] = $answerText;
                } elseif (strpos($questionText, 'name') !== false && !$contactData['name']) {
                    $contactData['name'] = $answerText;
                }
                
                // Extract email
                if (strpos($questionText, 'e-mail') !== false || strpos($questionText, 'email') !== false) {
                    $contactData['email'] = $answerText;
                }
                
                // Extract phone
                if (strpos($questionText, 'telefon') !== false || strpos($questionText, 'phone') !== false) {
                    $contactData['phone'] = $answerText;
                }
            }
        } else {
            // Old format: associative array with field keys
            $nameFields = [
                'name', 'vorname_nachname', 'vor_und_nachname', 'kunde_name', 
                'kundename', 'vollstaendiger_name', 'full_name', 'customer_name',
                'vor-und-nachname', 'vor_nachname', 'nachname_vorname'
            ];
            
            $emailFields = [
                'email', 'e_mail', 'e-mail', 'email_adresse', 'emailadresse',
                'mail', 'kontakt_email', 'kunde_email'
            ];
            
            $phoneFields = [
                'telefon', 'phone', 'telefonnummer', 'tel', 'handy', 'mobile',
                'kontakt_telefon', 'kunde_telefon', 'telefon_nummer'
            ];
            
            // Extract name
            foreach ($nameFields as $field) {
                if (isset($answers[$field]) && is_string($answers[$field]) && !empty(trim($answers[$field]))) {
                    $contactData['name'] = trim($answers[$field]);
                    break;
                }
            }
            
            // Extract email
            foreach ($emailFields as $field) {
                if (isset($answers[$field]) && is_string($answers[$field]) && !empty(trim($answers[$field]))) {
                    $contactData['email'] = trim($answers[$field]);
                    break;
                }
            }
            
            // Extract phone
            foreach ($phoneFields as $field) {
                if (isset($answers[$field]) && is_string($answers[$field]) && !empty(trim($answers[$field]))) {
                    $contactData['phone'] = trim($answers[$field]);
                    break;
                }
            }
        }
        
        return $contactData;
    }
    
    private function updateSubmissionStatus() {
        $id = $_POST['id'] ?? null;
        $status = $_POST['status'] ?? '';
        $notes = $_POST['notes'] ?? '';
        
        if (!$id || empty($status)) {
            return $this->error('ID and status are required');
        }
        
        try {
            $stmt = $this->db->prepare("UPDATE questionnaire_submissions SET status = ?, internal_notes = ?, processed_at = datetime('now') WHERE id = ?");
            $result = $stmt->execute([$status, $notes, $id]);
            
            if ($result) {
                return $this->success(['message' => 'Status erfolgreich aktualisiert']);
            } else {
                return $this->error('Failed to update status');
            }
            
        } catch (Exception $e) {
            return $this->error('Failed to update status: ' . $e->getMessage());
        }
    }
    
    private function generateOfferPDF() {
        $id = $_POST['id'] ?? null;
        if (!$id) {
            return $this->error('Submission ID required');
        }
        
        // Get pricing items from POST data
        $pricingItems = json_decode($_POST['pricing_items'] ?? '[]', true);
        $offerNotes = $_POST['offer_notes'] ?? '';
        $offerTerms = $_POST['offer_terms'] ?? '';
        $validUntil = $_POST['valid_until'] ?? '';
        $executionDate = $_POST['execution_date'] ?? '';
        
        if (empty($pricingItems)) {
            return $this->error('Keine Preispositionen gefunden');
        }
        
        try {
            $submission = $this->queryAll(
                "SELECT qs.*, s.name as service_name
                 FROM questionnaire_submissions qs
                 JOIN services s ON qs.service_id = s.id
                 WHERE qs.id = ?",
                [$id]
            )[0] ?? null;
            
            if (!$submission) {
                return $this->error('Submission not found');
            }
            
            // Extract contact data from form answers
            $formData = json_decode($submission['form_data'], true) ?? [];
            $answers = $formData['answers'] ?? [];
            $contactData = $this->extractContactDataFromAnswers($answers);
            
            // Load Kleinunternehmerregelung setting
            $kuSetting = $this->queryAll("SELECT setting_value, setting_type FROM settings WHERE setting_key = 'office_company_has_VAT' LIMIT 1");
            $this->debugLog("VAT Setting Query Result: " . print_r($kuSetting, true));
            
            $hasVAT = false; // Default: no VAT (Kleinunternehmer)
            if ($kuSetting) {
                $type = $kuSetting[0]['setting_type'];
                $value = $kuSetting[0]['setting_value'];
                $this->debugLog("VAT Setting - Type: $type, Value: '$value'");
                
                if ($type === 'bool') {
                    $hasVAT = ($value === '1' || $value === 1 || $value === true || $value === 'true');
                } elseif ($type === 'int') {
                    $hasVAT = ((int)$value === 1);
                } else {
                    // Fallback for string values
                    $hasVAT = (strtolower($value) === 'true' || $value === '1');
                }
            } else {
                $this->debugLog("No VAT setting found - defaulting to Kleinunternehmer mode");
            }
            
            // If company has VAT, it's NOT Kleinunternehmer
            $isKleinunternehmer = !$hasVAT;
            $this->debugLog("Has VAT: " . ($hasVAT ? 'true' : 'false'));
            $this->debugLog("Is Kleinunternehmer: " . ($isKleinunternehmer ? 'true' : 'false'));

            // Calculate totals
            $totalNet = array_sum(array_column($pricingItems, 'total'));
            $this->debugLog("Total Net: $totalNet");
            
            if ($isKleinunternehmer) {
                $vatAmount = 0.0;
                $totalGross = $totalNet;
                $this->debugLog("Kleinunternehmer mode: VAT = 0, Gross = Net = $totalGross");
            } else {
                $vatAmount = $totalNet * 0.19;
                $totalGross = $totalNet + $vatAmount;
                $this->debugLog("Standard mode: VAT = $vatAmount, Gross = $totalGross");
            }
            
            $offerData = [
                'offer_number' => 'ANG-' . date('ymd') . '-' . str_pad($id, 4, '0', STR_PAD_LEFT),
                'date' => date('d.m.Y'),
                'valid_until' => $validUntil ? date('d.m.Y', strtotime($validUntil)) : '',
                'execution_date' => $executionDate ? date('d.m.Y', strtotime($executionDate)) : '',
                'customer' => [
                    'name' => $contactData['name'] ?: 'Unbekannt',
                    'email' => $contactData['email'] ?: '',
                    'phone' => $contactData['phone'] ?: ''
                ],
                'submission' => [
                    'reference' => $submission['reference'],
                    'service_name' => $submission['service_name'],
                    'submitted_at' => date('d.m.Y', strtotime($submission['submitted_at']))
                ],
                'items' => $pricingItems,
                'totals' => [
                    'net' => $totalNet,
                    'vat_rate' => $isKleinunternehmer ? 0 : 19,
                    'vat_amount' => $vatAmount,
                    'gross' => $totalGross
                ],
                'notes' => $offerNotes,
                'terms' => $offerTerms,
                'kleinunternehmerregelung' => $isKleinunternehmer,
                'legal_note' => $isKleinunternehmer ? 'Gemäß §19 UStG wird keine Umsatzsteuer ausgewiesen.' : ''
            ];
            
            $this->debugLog("Final offer data totals: " . print_r($offerData['totals'], true));
            $this->debugLog("Kleinunternehmerregelung flag: " . ($offerData['kleinunternehmerregelung'] ? 'true' : 'false'));
            $this->debugLog("Legal note: " . $offerData['legal_note']);
            
            // Generate PDF using OfferPDFGenerator
            require_once __DIR__ . '/../src/Utils/OfferPDFGenerator.php';
            $pdfGenerator = new OfferPDFGenerator();
            
            $filename = 'angebot_' . $submission['reference'] . '_' . date('Y-m-d_H-i-s') . '.pdf';
            $outputPath = __DIR__ . '/../data/offers/';
            
            // Create directory if it doesn't exist
            if (!file_exists($outputPath)) {
                mkdir($outputPath, 0755, true);
            }
            
            $fullPath = $outputPath . $filename;
            $pdfGenerator->generateOffer($offerData, $fullPath);
            
            // Save offer to database
            require_once __DIR__ . '/../src/Models/Offer.php';
            $offerModel = new \DSAllround\Models\Offer($this->db);
            
            $dbOfferData = [
                'submission_id' => $id,
                'customer_name' => $contactData['name'] ?: 'Unbekannt',
                'customer_email' => $contactData['email'] ?? null,
                'customer_phone' => $contactData['phone'] ?? null,
                'service_id' => $submission['service_id'],
                'service_name' => $submission['service_name'],
                'pricing_items' => $pricingItems,
                'total_net' => $totalNet,
                'total_vat' => $vatAmount,
                'total_gross' => $totalGross,
                'vat_rate' => $isKleinunternehmer ? 0.00 : 19.00,
                'notes' => $offerNotes ?: null,
                'terms' => $offerTerms ?: null,
                'valid_until' => $validUntil ?: null,
                'execution_date' => $executionDate ?: null,
                'pdf_path' => 'data/offers/' . $filename,
                'created_by' => 'admin'
            ];
            
            $this->debugLog("Database offer data VAT rate: " . $dbOfferData['vat_rate']);
            
            $result = $offerModel->createOffer($dbOfferData);
            
            // Update submission status to "angebot_erstellt" if currently "neu" or "in_bearbeitung"
            if (in_array($submission['status'], ['neu', 'new', 'in_bearbeitung'])) {
                $this->db->prepare("UPDATE questionnaire_submissions SET status = 'angebot_erstellt', processed_at = datetime('now') WHERE id = ?")
                    ->execute([$id]);
            }
            
            return $this->success([
                'message' => 'Angebot erfolgreich erstellt und gespeichert',
                'offer_id' => $result['id'],
                'offer_number' => $result['offer_number'],
                'filename' => $filename,
                'pdf_url' => '/data/offers/' . $filename,
                'offer_data' => $offerData
            ]);
            
        } catch (Exception $e) {
            return $this->error('Failed to generate offer: ' . $e->getMessage());
        }
    }
    
    private function calculateOfferItems($serviceId, $answers) {
        $items = [];
        
        // Basic service calculations based on service type
        switch ($serviceId) {
            case 'umzuege':
                $basePrice = 200.00;
                $items[] = [
                    'description' => 'Umzugsservice - Grundpauschale',
                    'quantity' => 1,
                    'unit' => 'Pauschal',
                    'price' => $basePrice,
                    'total' => $basePrice
                ];
                
                // Add extra charges based on answers
                if (isset($answers['rooms']) && is_numeric($answers['rooms'])) {
                    $rooms = intval($answers['rooms']);
                    if ($rooms > 3) {
                        $extraRooms = $rooms - 3;
                        $extraPrice = $extraRooms * 50.00;
                        $items[] = [
                            'description' => 'Zusätzliche Räume',
                            'quantity' => $extraRooms,
                            'unit' => 'Raum',
                            'price' => 50.00,
                            'total' => $extraPrice
                        ];
                    }
                }
                
                if (isset($answers['distance']) && is_numeric($answers['distance'])) {
                    $distance = floatval($answers['distance']);
                    if ($distance > 50) {
                        $extraKm = $distance - 50;
                        $extraPrice = $extraKm * 1.50;
                        $items[] = [
                            'description' => 'Zusätzliche Entfernung (über 50km)',
                            'quantity' => $extraKm,
                            'unit' => 'km',
                            'price' => 1.50,
                            'total' => $extraPrice
                        ];
                    }
                }
                break;
                
            case 'entruempelung':
                $basePrice = 150.00;
                $items[] = [
                    'description' => 'Entrümpelung - Grundpauschale',
                    'quantity' => 1,
                    'unit' => 'Pauschal',
                    'price' => $basePrice,
                    'total' => $basePrice
                ];
                
                if (isset($answers['volume']) && is_numeric($answers['volume'])) {
                    $volume = intval($answers['volume']);
                    if ($volume > 10) {
                        $extraVolume = $volume - 10;
                        $extraPrice = $extraVolume * 15.00;
                        $items[] = [
                            'description' => 'Zusätzliches Volumen (über 10m³)',
                            'quantity' => $extraVolume,
                            'unit' => 'm³',
                            'price' => 15.00,
                            'total' => $extraPrice
                        ];
                    }
                }
                break;
                
            case 'transport':
                $basePrice = 80.00;
                $items[] = [
                    'description' => 'Transportservice - Grundpauschale',
                    'quantity' => 1,
                    'unit' => 'Pauschal',
                    'price' => $basePrice,
                    'total' => $basePrice
                ];
                break;
                
            case 'aufloesung':
                $basePrice = 300.00;
                $items[] = [
                    'description' => 'Haushaltsauflösung - Grundpauschale',
                    'quantity' => 1,
                    'unit' => 'Pauschal',
                    'price' => $basePrice,
                    'total' => $basePrice
                ];
                break;
                
            default:
                $basePrice = 100.00;
                $items[] = [
                    'description' => 'Service-Pauschale',
                    'quantity' => 1,
                    'unit' => 'Pauschal',
                    'price' => $basePrice,
                    'total' => $basePrice
                ];
                break;
        }
        
        return $items;
    }
    
    private function sendResponseEmail() {
        $id = $_POST['id'] ?? null;
        $template = $_POST['template'] ?? '';
        $customMessage = $_POST['message'] ?? '';
        
        if (!$id || empty($template)) {
            return $this->error('ID and template are required');
        }
        
        try {
            $submission = $this->queryAll(
                "SELECT qs.*, s.name as service_name
                 FROM questionnaire_submissions qs
                 JOIN services s ON qs.service_id = s.id
                 WHERE qs.id = ?",
                [$id]
            )[0] ?? null;
            
            if (!$submission) {
                return $this->error('Submission not found');
            }
            
            // Extract contact data from answers
            $formData = json_decode($submission['form_data'], true) ?? [];
            $answers = $formData['answers'] ?? [];
            $contactData = $this->extractContactDataFromAnswers($answers);
            
            // Enhance submission with extracted contact data
            $enhancedSubmission = $submission;
            $enhancedSubmission['extracted_name'] = $contactData['name'] ?: $submission['contact_name'];
            $enhancedSubmission['extracted_email'] = $contactData['email'] ?: $submission['contact_email'];
            $enhancedSubmission['extracted_phone'] = $contactData['phone'] ?: $submission['contact_phone'];
            
            // Get email template
            $emailContent = $this->getResponseEmailTemplate($template, $enhancedSubmission, $customMessage);
            
            // Send email (would need EmailService)
            // For now, return success
            return $this->success([
                'message' => 'E-Mail erfolgreich versendet',
                'email_content' => $emailContent
            ]);
            
        } catch (Exception $e) {
            return $this->error('Failed to send email: ' . $e->getMessage());
        }
    }
    
    private function getResponseEmailTemplate($template, $submission, $customMessage = '') {
        $templates = [
            'confirmation' => [
                'subject' => 'Bestätigung Ihrer Anfrage - ' . $submission['service_name'],
                'body' => "Liebe/r {customer_name},\n\nvielen Dank für Ihre Anfrage bezüglich {service_name}.\n\nWir haben Ihre Angaben erhalten und werden uns zeitnah bei Ihnen melden.\n\nIhre Referenznummer: {reference}\n\n{custom_message}\n\nMit freundlichen Grüßen\nIhr DS-Allroundservice Team"
            ],
            'quote_ready' => [
                'subject' => 'Ihr Kostenvoranschlag - ' . $submission['service_name'],
                'body' => "Liebe/r {customer_name},\n\nwir haben Ihren Kostenvoranschlag für {service_name} erstellt.\n\nDieser befindet sich im Anhang dieser E-Mail.\n\nReferenznummer: {reference}\n\n{custom_message}\n\nBei Fragen stehen wir Ihnen gerne zur Verfügung.\n\nMit freundlichen Grüßen\nIhr DS-Allroundservice Team"
            ],
            'appointment' => [
                'subject' => 'Terminvorschlag - ' . $submission['service_name'],
                'body' => "Liebe/r {customer_name},\n\ngerne möchten wir einen Termin mit Ihnen vereinbaren.\n\nService: {service_name}\nReferenznummer: {reference}\n\n{custom_message}\n\nBitte teilen Sie uns mit, welcher Termin für Sie passend ist.\n\nMit freundlichen Grüßen\nIhr DS-Allroundservice Team"
            ],
            'follow_up' => [
                'subject' => 'Nachfrage zu Ihrer Anfrage - ' . $submission['service_name'],
                'body' => "Liebe/r {customer_name},\n\nwir möchten uns bezüglich Ihrer Anfrage für {service_name} bei Ihnen melden.\n\nReferenznummer: {reference}\n\n{custom_message}\n\nFalls Sie noch Fragen haben oder weitere Informationen benötigen, kontaktieren Sie uns gerne.\n\nMit freundlichen Grüßen\nIhr DS-Allroundservice Team"
            ]
        ];
        
        $template_data = $templates[$template] ?? $templates['confirmation'];
        
        // Replace placeholders
        $placeholders = [
            '{customer_name}' => $submission['extracted_name'] ?? $submission['contact_name'] ?? 'Kunde',
            '{service_name}' => $submission['service_name'],
            '{reference}' => $submission['reference'],
            '{custom_message}' => $customMessage ? "\n" . $customMessage . "\n" : ''
        ];
        
        return [
            'subject' => str_replace(array_keys($placeholders), array_values($placeholders), $template_data['subject']),
            'body' => str_replace(array_keys($placeholders), array_values($placeholders), $template_data['body'])
        ];
    }

    // ========================================================================
    // Email Template Methods
    // ========================================================================
    
    private function getEmailTemplates() {
        try {
            $templates = $this->queryAll(
                "SELECT * FROM email_templates ORDER BY template_key ASC"
            );
            
            return $this->success(['templates' => $templates]);
        } catch (Exception $e) {
            return $this->error('Error getting email templates: ' . $e->getMessage());
        }
    }
    
    private function getEmailTemplate() {
        $id = $_GET['id'] ?? null;
        if (!$id) {
            return $this->error('Template ID required');
        }
        
        try {
            $template = $this->queryAll(
                "SELECT * FROM email_templates WHERE id = ?", 
                [$id]
            )[0] ?? null;
            
            if (!$template) {
                return $this->error('Template not found');
            }
            
            return $this->success(['template' => $template]);
        } catch (Exception $e) {
            return $this->error('Error getting email template: ' . $e->getMessage());
        }
    }
    
    private function saveEmailTemplate() {
        $id = $_POST['id'] ?? null;
        $templateKey = $_POST['template_key'] ?? '';
        $subject = $_POST['subject'] ?? '';
        $bodyHtml = $_POST['body_html'] ?? '';
        $bodyText = $_POST['body_text'] ?? '';
        $variables = $_POST['variables'] ?? '[]';
        $isActive = isset($_POST['is_active']) ? (int)$_POST['is_active'] : 1;
        
        if (!$templateKey || !$subject) {
            return $this->error('Template-Schlüssel und Betreff sind erforderlich');
        }
        
        try {
            if ($id) {
                // Update existing template
                $this->execute(
                    "UPDATE email_templates SET 
                     template_key = ?, subject = ?, body_html = ?, body_text = ?, 
                     variables = ?, is_active = ?, updated_at = CURRENT_TIMESTAMP
                     WHERE id = ?",
                    [$templateKey, $subject, $bodyHtml, $bodyText, $variables, $isActive, $id]
                );
            } else {
                // Create new template
                $this->execute(
                    "INSERT INTO email_templates 
                     (template_key, subject, body_html, body_text, variables, is_active)
                     VALUES (?, ?, ?, ?, ?, ?)",
                    [$templateKey, $subject, $bodyHtml, $bodyText, $variables, $isActive]
                );
            }
            
            return $this->success(['message' => 'E-Mail-Template erfolgreich gespeichert']);
        } catch (Exception $e) {
            if (strpos($e->getMessage(), 'UNIQUE constraint failed') !== false) {
                return $this->error('Ein Template mit diesem Schlüssel existiert bereits');
            }
            return $this->error('Error saving email template: ' . $e->getMessage());
        }
    }
    
    private function deleteEmailTemplate() {
        $id = $_POST['id'] ?? null;
        if (!$id) {
            return $this->error('Template ID required');
        }
        
        try {
            $this->execute("DELETE FROM email_templates WHERE id = ?", [$id]);
            return $this->success(['message' => 'E-Mail-Template erfolgreich gelöscht']);
        } catch (Exception $e) {
            return $this->error('Error deleting email template: ' . $e->getMessage());
        }
    }
    
    /**
     * E-Mail-Template-Vorschau generieren
     */
    public function previewEmailTemplate() {
        $id = $_GET['id'] ?? null;
        $templateKey = $_GET['template_key'] ?? null;
        
        if (!$id && !$templateKey) {
            return $this->error('Template ID or key required');
        }
        
        try {
            // Template aus Datenbank laden
            if ($id) {
                $templates = $this->queryAll("SELECT * FROM email_templates WHERE id = ?", [$id]);
                $template = $templates[0] ?? null;
            } else {
                $templates = $this->queryAll("SELECT * FROM email_templates WHERE template_key = ?", [$templateKey]);
                $template = $templates[0] ?? null;
            }
            
            if (!$template) {
                return $this->error('Template nicht gefunden');
            }
            
            // Beispieldaten für Vorschau generieren
            $sampleData = $this->generateSampleData($template['template_key']);
            
            // Template-Variablen dekodieren
            $templateVars = [];
            if (!empty($template['variables'])) {
                $templateVars = json_decode($template['variables'], true);
                if (json_last_error() !== JSON_ERROR_NONE) {
                    $templateVars = [];
                }
            }
            
            // Firmen-/System-Daten aus Einstellungen laden
            $companyData = $this->getCompanyVariables();
            
            // Dynamische Variablen hinzufügen
            $dynamicData = $this->getDynamicVariables(['reference' => $sampleData['reference'] ?? null]);
            
            // Alle Variablen zusammenführen (Priorität: sampleData > dynamicData > companyData > templateVars)
            $allVariables = array_merge($templateVars, $companyData, $dynamicData, $sampleData);
            
            // Subject rendern
            $subject = $this->processTemplateString($template['subject'], $allVariables, true);
            
            // HTML und Text Body rendern
            $bodyHtml = $this->processTemplateString($template['body_html'], $allVariables, true);
            $bodyText = $this->processTemplateString($template['body_text'], $allVariables, false); // Text ohne HTML-Highlighting
            
            // Conditionals verarbeiten
            $bodyHtml = $this->processConditionals($bodyHtml, $allVariables, true);
            $bodyText = $this->processConditionals($bodyText, $allVariables, false);
            
            return $this->success([
                'template_key' => $template['template_key'],
                'subject' => $subject,
                'body_html' => $bodyHtml,
                'body_text' => $bodyText,
                'variables' => $allVariables
            ]);
            
        } catch (Exception $e) {
            return $this->error('Error generating preview: ' . $e->getMessage());
        }
    }
    
    /**
     * Template-String mit Variablen verarbeiten
     */
    private function processTemplateString($template, $variables, $highlightVariables = false) {
        return preg_replace_callback('/\{\{([^}]+)\}\}/', function($matches) use ($variables, $highlightVariables) {
            $key = trim($matches[1]);
            if (isset($variables[$key])) {
                $value = $variables[$key];
                
                // Prüfe ob der Schlüssel "_html" enthält - dann nicht escapen
                if (strpos($key, '_html') !== false) {
                    // HTML-Inhalt nicht escapen
                    if ($highlightVariables) {
                        return '<span style="background-color: #fff3cd; padding: 2px 4px; border-radius: 3px; border: 1px solid #ffeaa7; display: inline-block;" title="Variable: ' . htmlspecialchars($key) . '">' . $value . '</span>';
                    }
                    return $value;
                } else {
                    // Normalen Text escapen
                    $escapedValue = htmlspecialchars($value, ENT_QUOTES, 'UTF-8');
                    if ($highlightVariables) {
                        return '<span style="background-color: #fff3cd; padding: 2px 4px; border-radius: 3px; border: 1px solid #ffeaa7;" title="Variable: ' . htmlspecialchars($key) . '">' . $escapedValue . '</span>';
                    }
                    return $escapedValue;
                }
            }
            return $highlightVariables ? '<span style="background-color: #f8d7da; padding: 2px 4px; border-radius: 3px; border: 1px solid #f5c6cb;" title="Unbekannte Variable: ' . htmlspecialchars($key) . '">{{' . htmlspecialchars($key) . '}}</span>' : '';
        }, $template);
    }
    
    /**
     * Conditional Blocks verarbeiten
     */
    private function processConditionals($template, $variables, $highlightVariables = false) {
        return preg_replace_callback('/\{\{#([^}]+)\}\}(.*?)\{\{\/\1\}\}/s', function($matches) use ($variables, $highlightVariables) {
            $key = trim($matches[1]);
            $content = $matches[2];
            
            if (isset($variables[$key]) && !empty($variables[$key])) {
                return $this->processTemplateString($content, $variables, $highlightVariables);
            }
            
            return '';
        }, $template);
    }
    
    /**
     * Beispieldaten für verschiedene Template-Typen generieren
     */
    private function generateSampleData($templateKey) {
        // Basis-Kundendaten
        $baseData = [
            'customer_name' => 'Max Mustermann',
            'customer_email' => 'max.mustermann@example.com',
            'customer_phone' => '+49 151 12345678',
            'customer_address' => 'Musterstraße 123, 12345 Musterstadt',
            'service_name' => 'Umzugsservice',
            'service_type' => 'Umzug',
            'reference' => 'AUF-' . date('Ymd') . '-' . rand(1000, 9999),
            'order_id' => 'AUF-' . date('Ymd') . '-' . rand(1000, 9999),
            'priority_text' => 'Normal',
            'status_text' => 'In Bearbeitung',
            'submitted_at' => date('d.m.Y H:i'),
            'processed_at' => date('d.m.Y H:i', strtotime('+1 hour')),
            'appointment_date' => date('d.m.Y', strtotime('+5 days')),
            'appointment_time' => '10:00',
            'customer_notes' => 'Bitte vorsichtig mit den Möbeln umgehen. Klaviertransport erforderlich.',
            'internal_notes' => 'Kunde bevorzugt Vormittagstermine.',
            'total_price' => '1.250,00 €',
            'estimated_duration' => '6 Stunden',
            'team_size' => '3 Personen',
            'id' => 'demo123',
            'current_date' => date('d.m.Y'),
            'current_time' => date('H:i'),
            'current_year' => date('Y')
        ];
        
        // Spezifische Daten je nach Template-Typ
        switch ($templateKey) {
            case 'customer_confirmation':
                $baseData['confirmation_message'] = 'Ihre Anfrage wurde erfolgreich eingereicht und wird schnellstmöglich bearbeitet.';
                $baseData['next_steps'] = 'Ein Mitarbeiter wird sich innerhalb von 24 Stunden bei Ihnen melden.';
                break;
                
            case 'quote_ready':
                $baseData['quote_amount'] = '1.250,00 €';
                $baseData['quote_valid_until'] = date('d.m.Y', strtotime('+14 days'));
                $baseData['quote_details'] = 'Umzug einer 3-Zimmer-Wohnung inkl. Verpackungsmaterial und Montageservice';
                $baseData['quote_items'] = "• Transport (6 Stunden): 750,00 €\n• Verpackungsmaterial: 150,00 €\n• Montageservice: 350,00 €";
                break;
                
            case 'service_completed':
                $baseData['completion_date'] = date('d.m.Y');
                $baseData['completion_time'] = '16:30';
                $baseData['service_summary'] = 'Umzug erfolgreich abgeschlossen. Alle Gegenstände wurden sicher und unbeschädigt transportiert.';
                $baseData['feedback_link'] = 'https://ds-allroundservice.de/feedback?ref=' . $baseData['reference'];
                break;
                
            case 'assignment_notification':
                $baseData['assigned_user_name'] = 'Thomas Weber';
                $baseData['assigned_user_email'] = 'thomas.weber@ds-allroundservice.de';
                $baseData['assigned_user_phone'] = '+49 151 98765432';
                break;
                
            case 'appointment_reminder':
                $baseData['reminder_message'] = 'Erinnerung an Ihren Termin morgen um ' . $baseData['appointment_time'] . ' Uhr.';
                $baseData['preparation_notes'] = 'Bitte stellen Sie sicher, dass alle zu transportierenden Gegenstände verpackt sind.';
                break;
        }
        
        // Simulierte Fragebogen-Antworten
        $baseData['answers_text'] = "Umzugsdatum: " . $baseData['appointment_date'] . "\nAnzahl Zimmer: 3 Zimmer + Küche + Bad\nEtage alt: 2. Stock (ohne Aufzug)\nEtage neu: Erdgeschoss\nBesonderheiten: Klavier (Flügel), Aquarium 500L\nHilfe beim Packen: Ja, benötigt\nVerpackungsmaterial: Wird benötigt";
        
        $baseData['answers_html'] = "<ul>" .
            "<li><strong>Umzugsdatum:</strong> " . $baseData['appointment_date'] . "</li>" .
            "<li><strong>Anzahl Zimmer:</strong> 3 Zimmer + Küche + Bad</li>" .
            "<li><strong>Etage alt:</strong> 2. Stock (ohne Aufzug)</li>" .
            "<li><strong>Etage neu:</strong> Erdgeschoss</li>" .
            "<li><strong>Besonderheiten:</strong> Klavier (Flügel), Aquarium 500L</li>" .
            "<li><strong>Hilfe beim Packen:</strong> Ja, benötigt</li>" .
            "<li><strong>Verpackungsmaterial:</strong> Wird benötigt</li>" .
            "</ul>";
        
        return $baseData;
    }
    
    // ========================================================================
    // Helper Methods
    // ========================================================================
    
    private function success($data = []) {
        return array_merge(['success' => true], $data);
    }
    
    private function error($message) {
        return ['success' => false, 'error' => $message];
    }
    
    /**
     * Clean email data to ensure valid JSON encoding
     */
    private function cleanEmailDataForJson($data) {
        if (is_array($data)) {
            $cleaned = [];
            foreach ($data as $key => $value) {
                $cleaned[$key] = $this->cleanEmailDataForJson($value);
            }
            return $cleaned;
        }
        
        if (is_string($data)) {
            // Ensure valid UTF-8
            if (!mb_check_encoding($data, 'UTF-8')) {
                // Try to convert
                $converted = mb_convert_encoding($data, 'UTF-8', 'UTF-8');
                if ($converted !== false) {
                    return $converted;
                }
                // If conversion fails, remove invalid characters
                return preg_replace('/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/u', '', $data);
            }
            return $data;
        }
        
        return $data;
    }

    // ========================================================================
    // Questionnaire Methods
    // ========================================================================

    private function getQuestionnaires() {
        try {
            $questionnaires = $this->queryAll(
                "SELECT q.*, s.name as service_name, s.slug as service_slug,
                        COUNT(qq.question_id) as question_count
                 FROM questionnaires q 
                 LEFT JOIN services s ON q.service_id = s.id
                 LEFT JOIN questionnaire_questions qq ON q.id = qq.questionnaire_id
                 GROUP BY q.id, s.name, s.slug
                 ORDER BY q.created_at DESC"
            );
            
            // Map 'title' to 'name' for frontend compatibility
            foreach ($questionnaires as &$questionnaire) {
                $questionnaire['name'] = $questionnaire['title'];
            }

            return $this->success(['questionnaires' => $questionnaires]);
        } catch (Exception $e) {
            return $this->error('Error getting questionnaires: ' . $e->getMessage());
        }
    }

    private function getQuestionnaire() {
        $id = $_GET['id'] ?? null;
        if (!$id) {
            return $this->error('Questionnaire ID required');
        }

        try {
            $questionnaire = $this->queryAll(
                "SELECT q.*, s.name as service_name
                 FROM questionnaires q 
                 LEFT JOIN services s ON q.service_id = s.id
                 WHERE q.id = ?", 
                [$id]
            )[0] ?? null;

            if (!$questionnaire) {
                return $this->error('Questionnaire not found');
            }
            
            // Map 'title' to 'name' for frontend compatibility
            $questionnaire['name'] = $questionnaire['title'];

            return $this->success(['questionnaire' => $questionnaire]);
        } catch (Exception $e) {
            return $this->error('Error getting questionnaire: ' . $e->getMessage());
        }
    }

    private function createQuestionnaire() {
        $title = $_POST['name'] ?? ''; // Frontend sends 'name', but we store as 'title'
        $serviceId = $_POST['service_id'] ?? '';
        $description = $_POST['description'] ?? '';
        $status = $_POST['status'] ?? 'draft';

        if (!$title || !$serviceId) {
            return $this->error('Name and service are required');
        }

        try {
            $this->execute(
                "INSERT INTO questionnaires (title, service_id, description, status, created_at) 
                 VALUES (?, ?, ?, ?, datetime('now'))",
                [$title, $serviceId, $description, $status]
            );
            
            $questionnaireId = $this->db->lastInsertId();
            
            // ✅ Automatically add fixed contact fields to new questionnaire
            require_once __DIR__ . '/../src/Utils/FixedContactFieldsManager.php';
            $fixedFieldsManager = new FixedContactFieldsManager($this->db);
            $result = $fixedFieldsManager->createFixedContactFields($questionnaireId);
            
            error_log("✅ Created questionnaire {$questionnaireId} with fixed contact fields: Group ID {$result['group_id']}, " . count($result['question_ids']) . " questions");

            return $this->success([
                'message' => 'Questionnaire created successfully',
                'questionnaire_id' => $questionnaireId,
                'fixed_fields' => $result
            ]);
        } catch (Exception $e) {
            return $this->error('Error creating questionnaire: ' . $e->getMessage());
        }
    }

    private function updateQuestionnaire() {
        $id = $_POST['id'] ?? '';
        $title = $_POST['name'] ?? ''; // Frontend sends 'name', but we store as 'title'
        $serviceId = $_POST['service_id'] ?? '';
        $description = $_POST['description'] ?? '';
        $status = $_POST['status'] ?? 'draft';

        if (!$id || !$title || !$serviceId) {
            return $this->error('ID, name and service are required');
        }

        try {
            $this->execute(
                "UPDATE questionnaires 
                 SET title = ?, service_id = ?, description = ?, status = ?, updated_at = datetime('now')
                 WHERE id = ?",
                [$title, $serviceId, $description, $status, $id]
            );

            return $this->success(['message' => 'Questionnaire updated successfully']);
        } catch (Exception $e) {
            return $this->error('Error updating questionnaire: ' . $e->getMessage());
        }
    }

    private function deleteQuestionnaire() {
        $id = $_POST['id'] ?? '';
        if (!$id) {
            return $this->error('Questionnaire ID required');
        }

        try {
            // Delete questionnaire questions first (foreign key constraint)
            $this->execute("DELETE FROM questionnaire_questions WHERE questionnaire_id = ?", [$id]);
            
            // Delete questionnaire
            $this->execute("DELETE FROM questionnaires WHERE id = ?", [$id]);

            return $this->success(['message' => 'Questionnaire deleted successfully']);
        } catch (Exception $e) {
            return $this->error('Error deleting questionnaire: ' . $e->getMessage());
        }
    }

    private function getQuestionnaireQuestions() {
        $id = $_GET['id'] ?? null;
        if (!$id) {
            return $this->error('Questionnaire ID required');
        }

        try {
            // Get questions for this questionnaire, including group information
            $questions = $this->queryAll(
                "SELECT q.*, qg.name as group_name, qg.sort_order as group_order, qq.sort_order as question_order, qq.group_id
                 FROM questionnaire_questions qq
                 INNER JOIN questions_simple q ON qq.question_id = q.id
                 LEFT JOIN question_groups qg ON qq.group_id = qg.id
                 WHERE qq.questionnaire_id = ?
                 ORDER BY 
                    CASE WHEN qq.group_id IS NULL THEN 1 ELSE 0 END,
                    COALESCE(qg.sort_order, 999) ASC,
                    COALESCE(qq.sort_order, 999) ASC, 
                    q.id ASC",
                [$id]
            );

            return $this->success(['questions' => $questions]);
        } catch (Exception $e) {
            return $this->error('Error getting questionnaire questions: ' . $e->getMessage());
        }
    }

    // ========================================================================
    // Question Methods
    // ========================================================================

    private function getQuestions() {
        try {
            // Enhanced query to include questionnaire usage information
            $questions = $this->queryAll(
                "SELECT q.id,
                        q.question_text,
                        q.question_type,
                        q.is_required,
                        q.placeholder_text,
                        q.help_text,
                        q.options,
                        q.validation_rules,
                        q.created_at,
                        q.updated_at,
                        GROUP_CONCAT(DISTINCT qst.title) as used_in_questionnaires,
                        COUNT(DISTINCT qq.questionnaire_id) as usage_count
                 FROM questions_simple q 
                 LEFT JOIN questionnaire_questions qq ON q.id = qq.question_id
                 LEFT JOIN questionnaires qst ON qq.questionnaire_id = qst.id AND qst.status != 'archived'
                 GROUP BY q.id
                 ORDER BY q.created_at DESC"
            );

            // Format the data for frontend
            foreach ($questions as &$question) {
                $question['used_in'] = $question['used_in_questionnaires'] ?? '';
                $question['usage_count'] = (int)($question['usage_count'] ?? 0);
                $question['can_delete'] = $question['usage_count'] == 0;
                // Clean up temporary field
                unset($question['used_in_questionnaires']);
            }

            return $this->success(['questions' => $questions]);
        } catch (Exception $e) {
            return $this->error('Error getting questions: ' . $e->getMessage());
        }
    }

    private function getQuestion() {
        $id = $_GET['id'] ?? null;
        if (!$id) {
            return $this->error('Question ID required');
        }

        try {
            $question = $this->queryAll(
                "SELECT * FROM questions_simple WHERE id = ?", 
                [$id]
            )[0] ?? null;

            if (!$question) {
                return $this->error('Question not found');
            }

            return $this->success(['question' => $question]);
        } catch (Exception $e) {
            return $this->error('Error getting question: ' . $e->getMessage());
        }
    }

    private function createQuestion() {
        $questionText = $_POST['question_text'] ?? '';
        $questionType = $_POST['question_type'] ?? '';
        $isRequired = $_POST['is_required'] ?? 0;
        $placeholder = $_POST['placeholder_text'] ?? '';
        $helpText = $_POST['help_text'] ?? '';
        $options = $_POST['options'] ?? '';
        $validation = $_POST['validation_rules'] ?? '';

        if (!$questionText || !$questionType) {
            return $this->error('Question text and type are required');
        }

        try {
            $this->execute(
                "INSERT INTO questions_simple (question_text, question_type, is_required, placeholder_text, help_text, options, validation_rules, created_at) 
                 VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'))",
                [$questionText, $questionType, $isRequired, $placeholder, $helpText, $options, $validation]
            );

            return $this->success(['message' => 'Question created successfully']);
        } catch (Exception $e) {
            return $this->error('Error creating question: ' . $e->getMessage());
        }
    }

    private function updateQuestion() {
        $id = $_POST['id'] ?? '';
        $questionText = $_POST['question_text'] ?? '';
        $questionType = $_POST['question_type'] ?? '';
        $isRequired = $_POST['is_required'] ?? 0;
        $placeholder = $_POST['placeholder_text'] ?? '';
        $helpText = $_POST['help_text'] ?? '';
        $options = $_POST['options'] ?? '';
        $validation = $_POST['validation_rules'] ?? '';

        if (!$id || !$questionText || !$questionType) {
            return $this->error('ID, question text and type are required');
        }

        try {
            $this->execute(
                "UPDATE questions_simple 
                 SET question_text = ?, question_type = ?, is_required = ?, placeholder_text = ?, help_text = ?, options = ?, validation_rules = ?, updated_at = datetime('now')
                 WHERE id = ?",
                [$questionText, $questionType, $isRequired, $placeholder, $helpText, $options, $validation, $id]
            );

            return $this->success(['message' => 'Question updated successfully']);
        } catch (Exception $e) {
            return $this->error('Error updating question: ' . $e->getMessage());
        }
    }

    private function deleteQuestion() {
        $id = $_POST['id'] ?? '';
        if (!$id) {
            return $this->error('Question ID required');
        }

        try {
            // Check if question is used in any questionnaires
            $usage = $this->queryAll(
                "SELECT COUNT(DISTINCT qq.questionnaire_id) as usage_count,
                        GROUP_CONCAT(DISTINCT qst.title) as questionnaire_names
                 FROM questionnaire_questions qq
                 JOIN questionnaires qst ON qq.questionnaire_id = qst.id
                 WHERE qq.question_id = ? AND qst.status != 'archived'",
                [$id]
            )[0] ?? ['usage_count' => 0, 'questionnaire_names' => ''];

            if ($usage['usage_count'] > 0) {
                return $this->error("Diese Frage kann nicht gelöscht werden, da sie in folgenden Fragebögen verwendet wird: " . $usage['questionnaire_names']);
            }

            // Delete the question if not used
            $this->execute("DELETE FROM questions_simple WHERE id = ?", [$id]);
            return $this->success(['message' => 'Question deleted successfully']);
        } catch (Exception $e) {
            return $this->error('Error deleting question: ' . $e->getMessage());
        }
    }

    // ========================================================================
    // Questionnaire-Question Relationship Methods
    // ========================================================================

    private function addQuestionToQuestionnaire() {
        $questionnaireId = $_POST['questionnaire_id'] ?? '';
        $questionId = $_POST['question_id'] ?? '';
        $sortOrder = $_POST['sort_order'] ?? 0;

        if (!$questionnaireId || !$questionId) {
            return $this->error('Questionnaire ID and Question ID are required');
        }

        try {
            // Check if relationship already exists
            $existing = $this->queryAll(
                "SELECT id FROM questionnaire_questions WHERE questionnaire_id = ? AND question_id = ?",
                [$questionnaireId, $questionId]
            );

            if (!empty($existing)) {
                return $this->error('Question is already added to this questionnaire');
            }

            // Add the relationship
            $this->execute(
                "INSERT INTO questionnaire_questions (questionnaire_id, question_id, sort_order, created_at) 
                 VALUES (?, ?, ?, datetime('now'))",
                [$questionnaireId, $questionId, $sortOrder]
            );

            return $this->success(['message' => 'Question added to questionnaire successfully']);
        } catch (Exception $e) {
            return $this->error('Error adding question to questionnaire: ' . $e->getMessage());
        }
    }

    private function removeQuestionFromQuestionnaire() {
        $questionnaireId = $_POST['questionnaire_id'] ?? '';
        $questionId = $_POST['question_id'] ?? '';

        if (!$questionnaireId || !$questionId) {
            return $this->error('Questionnaire ID and Question ID are required');
        }

        try {
            $this->execute(
                "DELETE FROM questionnaire_questions WHERE questionnaire_id = ? AND question_id = ?",
                [$questionnaireId, $questionId]
            );

            return $this->success(['message' => 'Question removed from questionnaire successfully']);
        } catch (Exception $e) {
            return $this->error('Error removing question from questionnaire: ' . $e->getMessage());
        }
    }

    // ========================================
    // Groups Management Methods
    // ========================================

    private function getQuestionnaireGroups() {
        $questionnaireId = $_REQUEST['questionnaire_id'] ?? $_REQUEST['id'] ?? '';
        
        if (!$questionnaireId) {
            return $this->error('Questionnaire ID is required');
        }

        try {
            $stmt = $this->db->prepare("
                SELECT * FROM question_groups 
                WHERE questionnaire_id = ? 
                ORDER BY COALESCE(sort_order, 999) ASC, name ASC
            ");
            $stmt->execute([$questionnaireId]);
            $groups = $stmt->fetchAll();

            return $this->success(['groups' => $groups]);
        } catch (Exception $e) {
            return $this->error('Error getting questionnaire groups: ' . $e->getMessage());
        }
    }

    private function createGroup() {
        // Handle both JSON and POST data
        $input = json_decode(file_get_contents('php://input'), true);
        $questionnaireId = $input['questionnaire_id'] ?? $_POST['questionnaire_id'] ?? '';
        $name = $input['name'] ?? $_POST['name'] ?? '';
        $description = $input['description'] ?? $_POST['description'] ?? '';
        $questionIds = $input['question_ids'] ?? (isset($_POST['question_ids']) ? (is_array($_POST['question_ids']) ? $_POST['question_ids'] : json_decode($_POST['question_ids'], true)) : []);

        if (!$questionnaireId || !$name) {
            return $this->error('Questionnaire ID and name are required');
        }

        try {
            $this->db->beginTransaction();

            // Get next order position
            $stmt = $this->db->prepare("SELECT COALESCE(MAX(sort_order), 0) + 1 FROM question_groups WHERE questionnaire_id = ?");
            $stmt->execute([$questionnaireId]);
            $orderPosition = $stmt->fetchColumn();

            // Create group
            $stmt = $this->db->prepare("
                INSERT INTO question_groups (questionnaire_id, name, description, sort_order) 
                VALUES (?, ?, ?, ?)
            ");
            $stmt->execute([$questionnaireId, $name, $description, $orderPosition]);
            $groupId = $this->db->lastInsertId();

            // Move questions to group if provided
            if (!empty($questionIds)) {
                $placeholders = str_repeat('?,', count($questionIds) - 1) . '?';
                $stmt = $this->db->prepare("UPDATE questions_simple SET group_id = ? WHERE id IN ($placeholders)");
                $params = array_merge([$groupId], $questionIds);
                $stmt->execute($params);
            }

            $this->db->commit();

            // Get created group
            $stmt = $this->db->prepare("SELECT * FROM question_groups WHERE id = ?");
            $stmt->execute([$groupId]);
            $group = $stmt->fetch();

            return $this->success(['group' => $group, 'message' => 'Group created successfully']);
        } catch (Exception $e) {
            $this->db->rollback();
            return $this->error('Error creating group: ' . $e->getMessage());
        }
    }

    private function updateGroup() {
        // Get JSON input like other methods
        $input = json_decode(file_get_contents('php://input'), true);
        
        $groupId = $input['id'] ?? '';
        $name = $input['name'] ?? '';
        $description = $input['description'] ?? '';

        if (!$groupId || !$name) {
            return $this->error('Group ID and name are required');
        }

        try {
            // Check if group is fixed (not editable)
            $stmt = $this->db->prepare("SELECT is_fixed, name FROM question_groups WHERE id = ?");
            $stmt->execute([$groupId]);
            $group = $stmt->fetch(PDO::FETCH_ASSOC);
            
            if (!$group) {
                return $this->error('Group not found');
            }
            
            if (isset($group['is_fixed']) && $group['is_fixed'] == 1) {
                return $this->error('Feste Kontaktgruppe kann nicht bearbeitet werden. Diese Gruppe enthält die standardmäßigen Kontaktfelder.');
            }

            $stmt = $this->db->prepare("
                UPDATE question_groups 
                SET name = ?, description = ? 
                WHERE id = ? AND (is_fixed = 0 OR is_fixed IS NULL)
            ");
            $stmt->execute([$name, $description, $groupId]);
            
            if ($stmt->rowCount() === 0) {
                return $this->error('Gruppe konnte nicht aktualisiert werden. Möglicherweise ist sie als fest markiert.');
            }

            // Get updated group
            $stmt = $this->db->prepare("SELECT * FROM question_groups WHERE id = ?");
            $stmt->execute([$groupId]);
            $group = $stmt->fetch();

            return $this->success(['group' => $group, 'message' => 'Group updated successfully']);
        } catch (Exception $e) {
            return $this->error('Error updating group: ' . $e->getMessage());
        }
    }

    private function deleteGroup() {
        // Handle both JSON and POST data
        $input = json_decode(file_get_contents('php://input'), true);
        $groupId = $input['id'] ?? $_REQUEST['id'] ?? $_POST['id'] ?? '';

        if (!$groupId) {
            return $this->error('Group ID is required');
        }

        try {
            // Check if group is fixed (not deletable)
            $stmt = $this->db->prepare("SELECT is_fixed, name FROM question_groups WHERE id = ?");
            $stmt->execute([$groupId]);
            $group = $stmt->fetch(PDO::FETCH_ASSOC);
            
            if (!$group) {
                return $this->error('Group not found');
            }
            
            if (isset($group['is_fixed']) && $group['is_fixed'] == 1) {
                return $this->error('Feste Kontaktgruppe kann nicht gelöscht werden. Diese Gruppe enthält die standardmäßigen Kontaktfelder.');
            }

            $this->db->beginTransaction();

            // Move all questions from this group to ungrouped
            $stmt = $this->db->prepare("UPDATE questions_simple SET group_id = NULL WHERE group_id = ?");
            $stmt->execute([$groupId]);

            // Delete the group (only if not fixed)
            $stmt = $this->db->prepare("DELETE FROM question_groups WHERE id = ? AND (is_fixed = 0 OR is_fixed IS NULL)");
            $stmt->execute([$groupId]);
            
            if ($stmt->rowCount() === 0) {
                $this->db->rollback();
                return $this->error('Gruppe konnte nicht gelöscht werden. Möglicherweise ist sie als fest markiert.');
            }

            $this->db->commit();

            return $this->success(['message' => 'Group deleted successfully']);
        } catch (Exception $e) {
            $this->db->rollback();
            return $this->error('Error deleting group: ' . $e->getMessage());
        }
    }

    private function moveQuestion() {
        $questionId = $_POST['question_id'] ?? '';
        $targetGroupId = $_POST['target_group_id'] ?? null;
        $position = $_POST['position'] ?? 0;

        if (!$questionId) {
            return $this->error('Question ID is required');
        }

        // Handle "ungrouped" as null
        if ($targetGroupId === 'ungrouped' || $targetGroupId === '') {
            $targetGroupId = null;
        }

        try {
            // Update question's group and position
            $stmt = $this->db->prepare("
                UPDATE questions_simple 
                SET group_id = ?, sort_order = ? 
                WHERE id = ?
            ");
            $stmt->execute([$targetGroupId, $position, $questionId]);

            // Reorder questions in target group
            $this->reorderQuestionsInGroup($targetGroupId);

            return $this->success(['message' => 'Question moved successfully']);
        } catch (Exception $e) {
            return $this->error('Error moving question: ' . $e->getMessage());
        }
    }

    private function reorderQuestions() {
        // Handle both JSON and POST data
        $input = json_decode(file_get_contents('php://input'), true);
        $questions = $input['questions'] ?? $_POST['questions'] ?? [];
        $groupId = $input['group_id'] ?? $_POST['group_id'] ?? null;
        $questionnaireId = $input['questionnaire_id'] ?? $_POST['questionnaire_id'] ?? '';

        // Debug logging
        error_log("reorderQuestions Debug - Input: " . json_encode($input));
        error_log("reorderQuestions Debug - Questions: " . json_encode($questions));
        error_log("reorderQuestions Debug - Questions count: " . count($questions));

        if (empty($questions)) {
            return $this->error('Questions array is required');
        }

        // Handle "ungrouped" as null
        if ($groupId === 'ungrouped' || $groupId === '') {
            $groupId = null;
        }

        try {
            $this->db->beginTransaction();

            $stmt = $this->db->prepare("UPDATE questions_simple SET sort_order = ? WHERE id = ?");
            
            foreach ($questions as $index => $questionId) {
                $stmt->execute([$index + 1, $questionId]);
            }

            $this->db->commit();

            return $this->success(['message' => 'Questions reordered successfully']);
        } catch (Exception $e) {
            $this->db->rollback();
            return $this->error('Error reordering questions: ' . $e->getMessage());
        }
    }

    private function reorderQuestionsInGroup($groupId) {
        try {
            if ($groupId === null) {
                $stmt = $this->db->prepare("
                    SELECT id FROM questions_simple 
                    WHERE group_id IS NULL 
                    ORDER BY sort_order, id
                ");
                $stmt->execute();
            } else {
                $stmt = $this->db->prepare("
                    SELECT id FROM questions_simple 
                    WHERE group_id = ? 
                    ORDER BY sort_order, id
                ");
                $stmt->execute([$groupId]);
            }

            $questions = $stmt->fetchAll(PDO::FETCH_COLUMN);
            
            $updateStmt = $this->db->prepare("UPDATE questions_simple SET sort_order = ? WHERE id = ?");
            foreach ($questions as $index => $questionId) {
                $updateStmt->execute([$index + 1, $questionId]);
            }
        } catch (Exception $e) {
            error_log("Error reordering questions in group: " . $e->getMessage());
        }
    }

    // ========================================================================
    // New Enhanced Group Management Methods
    // ========================================================================

    private function moveQuestionToGroup() {
        $input = json_decode(file_get_contents('php://input'), true);
        $questionId = $input['question_id'] ?? null;
        $targetGroupId = $input['target_group_id'] ?? null;
        $position = $input['position'] ?? 0;
        $questionnaireId = $input['questionnaire_id'] ?? null;

        if (!$questionId || !$questionnaireId) {
            return $this->error('Question ID and Questionnaire ID required');
        }

        // Handle "ungrouped" as null
        if ($targetGroupId === 'ungrouped' || $targetGroupId === '') {
            $targetGroupId = null;
        }

        try {
            // Update the question's group assignment in questionnaire_questions table
            $this->query(
                "UPDATE questionnaire_questions SET group_id = ? WHERE question_id = ? AND questionnaire_id = ?",
                [$targetGroupId, $questionId, $questionnaireId]
            );

            // Update the sort order in questionnaire_questions table  
            $this->query(
                "UPDATE questionnaire_questions SET sort_order = ? WHERE question_id = ? AND questionnaire_id = ?",
                [$position, $questionId, $questionnaireId]
            );

            return $this->success(['message' => 'Question moved successfully']);
        } catch (Exception $e) {
            return $this->error('Error moving question: ' . $e->getMessage());
        }
    }

    private function reorderGroups() {
        $input = json_decode(file_get_contents('php://input'), true);
        $groups = $input['groups'] ?? [];
        $questionnaireId = $input['questionnaire_id'] ?? null;

        if (!$questionnaireId) {
            return $this->error('Questionnaire ID required');
        }

        try {
            $updateStmt = $this->db->prepare(
                "UPDATE question_groups SET sort_order = ? WHERE id = ? AND questionnaire_id = ?"
            );

            foreach ($groups as $index => $groupId) {
                $updateStmt->execute([$index + 1, $groupId, $questionnaireId]);
            }

            return $this->success(['message' => 'Groups reordered successfully']);
        } catch (Exception $e) {
            return $this->error('Error reordering groups: ' . $e->getMessage());
        }
    }

    private function createGroupFromQuestions() {
        $input = json_decode(file_get_contents('php://input'), true);
        $name = $input['name'] ?? null;
        $questionIds = $input['question_ids'] ?? [];
        $questionnaireId = $input['questionnaire_id'] ?? null;
        $description = $input['description'] ?? '';

        if (!$name || !$questionnaireId || empty($questionIds)) {
            return $this->error('Name, questionnaire ID, and question IDs required');
        }

        try {
            // Begin transaction
            $this->db->beginTransaction();

            // Create the group
            $groupStmt = $this->query(
                "INSERT INTO question_groups (questionnaire_id, name, description, sort_order, created_at) 
                 VALUES (?, ?, ?, COALESCE((SELECT MAX(sort_order) FROM question_groups WHERE questionnaire_id = ?) + 1, 1), datetime('now'))",
                [$questionnaireId, $name, $description, $questionnaireId]
            );

            $groupId = $this->db->lastInsertId();

            // Move questions to the new group
            $questionUpdateStmt = $this->db->prepare(
                "UPDATE questions_simple SET group_id = ? WHERE id = ?"
            );

            foreach ($questionIds as $index => $questionId) {
                $questionUpdateStmt->execute([$groupId, $questionId]);
                
                // Also update the sort order in questionnaire_questions
                $this->query(
                    "UPDATE questionnaire_questions SET sort_order = ? WHERE question_id = ? AND questionnaire_id = ?",
                    [$index + 1, $questionId, $questionnaireId]
                );
            }

            $this->db->commit();

            return $this->success([
                'message' => 'Group created successfully',
                'group_id' => $groupId
            ]);
        } catch (Exception $e) {
            $this->db->rollBack();
            return $this->error('Error creating group from questions: ' . $e->getMessage());
        }
    }
    
    private function removeQuestionFromGroup() {
        try {
            $input = json_decode(file_get_contents('php://input'), true);
            $questionId = $input['question_id'] ?? null;

            if (!$questionId) {
                return $this->error('Question ID is required');
            }

            $this->db->beginTransaction();

            // Remove question from group by setting group_id to NULL
            $stmt = $this->db->prepare(
                "UPDATE questions_simple SET group_id = NULL WHERE id = ?"
            );
            $stmt->execute([$questionId]);

            $this->db->commit();

            return $this->success([
                'message' => 'Question removed from group successfully'
            ]);
        } catch (Exception $e) {
            $this->db->rollBack();
            return $this->error('Error removing question from group: ' . $e->getMessage());
        }
    }
    
    /**
     * Get service page content for editing
     */
    private function getServicePageContent() {
        try {
            $slug = $_GET['slug'] ?? '';
            if (empty($slug)) {
                return $this->error('Service slug is required');
            }
            
            // Get service data
            $stmt = $this->db->prepare("SELECT * FROM services WHERE slug = ?");
            $stmt->execute([$slug]);
            $service = $stmt->fetch();
            
            if (!$service) {
                return $this->error('Service not found');
            }
            
            // Get service page content
            $stmt = $this->db->prepare("SELECT * FROM service_pages WHERE service_id = ?");
            $stmt->execute([$service['id']]);
            $content = $stmt->fetch();
            
            return $this->success([
                'service' => $service,
                'content' => $content
            ]);
        } catch (Exception $e) {
            return $this->error('Error loading service content: ' . $e->getMessage());
        }
    }
    
    /**
     * Save service page content
     */
    private function saveServicePageContent() {
        try {
            $serviceId = $_POST['service_id'] ?? '';
            $serviceSlug = $_POST['service_slug'] ?? '';
            
            if (empty($serviceId) || empty($serviceSlug)) {
                return $this->error('Service ID and slug are required');
            }
            
            // Prepare content data
            $contentData = [
                'service_id' => $serviceId,
                'meta_title' => $_POST['meta_title'] ?? '',
                'meta_description' => $_POST['meta_description'] ?? '',
                'meta_keywords' => $_POST['meta_keywords'] ?? '',
                'hero_title' => $_POST['hero_title'] ?? '',
                'hero_subtitle' => $_POST['hero_subtitle'] ?? '',
                'intro_title' => $_POST['intro_title'] ?? '',
                'intro_content' => $_POST['intro_content'] ?? '',
                'features_title' => $_POST['features_title'] ?? '',
                'features_subtitle' => $_POST['features_subtitle'] ?? '',
                'features_content' => $_POST['features_content'] ?? '',
                'process_title' => $_POST['process_title'] ?? '',
                'process_subtitle' => $_POST['process_subtitle'] ?? '',
                'process_content' => $_POST['process_content'] ?? '',
                'pricing_title' => $_POST['pricing_title'] ?? '',
                'pricing_subtitle' => $_POST['pricing_subtitle'] ?? '',
                'faq_title' => $_POST['faq_title'] ?? '',
                'faq_content' => $_POST['faq_content'] ?? ''
            ];
            
            // Check if service page content already exists
            $stmt = $this->db->prepare("SELECT id FROM service_pages WHERE service_id = ?");
            $stmt->execute([$serviceId]);
            $existingContent = $stmt->fetch();
            
            if ($existingContent) {
                // Update existing content
                $stmt = $this->db->prepare("
                    UPDATE service_pages SET 
                        meta_title = ?, meta_description = ?, meta_keywords = ?,
                        hero_title = ?, hero_subtitle = ?,
                        intro_title = ?, intro_content = ?,
                        features_title = ?, features_subtitle = ?, features_content = ?,
                        process_title = ?, process_subtitle = ?, process_content = ?,
                        pricing_title = ?, pricing_subtitle = ?,
                        faq_title = ?, faq_content = ?,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE service_id = ?
                ");
                $stmt->execute([
                    $contentData['meta_title'], $contentData['meta_description'], $contentData['meta_keywords'],
                    $contentData['hero_title'], $contentData['hero_subtitle'],
                    $contentData['intro_title'], $contentData['intro_content'],
                    $contentData['features_title'], $contentData['features_subtitle'], $contentData['features_content'],
                    $contentData['process_title'], $contentData['process_subtitle'], $contentData['process_content'],
                    $contentData['pricing_title'], $contentData['pricing_subtitle'],
                    $contentData['faq_title'], $contentData['faq_content'],
                    $serviceId
                ]);
            } else {
                // Insert new content
                $stmt = $this->db->prepare("
                    INSERT INTO service_pages (
                        service_id, meta_title, meta_description, meta_keywords,
                        hero_title, hero_subtitle,
                        intro_title, intro_content,

                        features_title, features_subtitle, features_content,
                        process_title, process_subtitle, process_content,
                        pricing_title, pricing_subtitle,
                        faq_title, faq_content, created_at, updated_at
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
                ");
                $stmt->execute([
                    $serviceId,
                    $contentData['meta_title'], $contentData['meta_description'], $contentData['meta_keywords'],
                    $contentData['hero_title'], $contentData['hero_subtitle'],
                    $contentData['intro_title'], $contentData['intro_content'],
                    $contentData['features_title'], $contentData['features_subtitle'], $contentData['features_content'],
                    $contentData['process_title'], $contentData['process_subtitle'], $contentData['process_content'],
                    $contentData['pricing_title'], $contentData['pricing_subtitle'],
                    $contentData['faq_title'], $contentData['faq_content']
                ]);
            }
            
            return $this->success([
                'message' => 'Service page content saved successfully'
            ]);
        } catch (Exception $e) {
            return $this->error('Error saving service content: ' . $e->getMessage());
        }
    }
    
    // ========================================================================
    // Image Management Methods
    // ========================================================================
    
    private function getImages() {
        try {
            $images = $this->queryAll(
                "SELECT * FROM images ORDER BY created_at DESC"
            );
            
            // Add full path and additional info for each image
            foreach ($images as &$image) {
                $imagePath = __DIR__ . '/../public/assets/img/' . $image['name'];
                $image['path'] = '/public/assets/img/' . $image['name'];
                $image['full_path'] = $imagePath;
                $image['exists'] = file_exists($imagePath);
                
                if ($image['exists']) {
                    $image['size'] = filesize($imagePath);
                    $image['size_formatted'] = $this->formatFileSize($image['size']);
                    
                    // Get image dimensions - special handling for SVG
                    $fileExtension = strtolower(pathinfo($image['name'], PATHINFO_EXTENSION));
                    if ($fileExtension === 'svg') {
                        // Try to get SVG dimensions from the file content
                        $svgInfo = $this->getSvgDimensions($imagePath);
                        if ($svgInfo) {
                            $image['width'] = $svgInfo['width'];
                            $image['height'] = $svgInfo['height'];
                            $image['dimensions'] = $svgInfo['width'] . 'x' . $svgInfo['height'];
                            $image['mime_type'] = 'image/svg+xml';
                        } else {
                            $image['dimensions'] = 'SVG (vector)';
                            $image['mime_type'] = 'image/svg+xml';
                        }
                    } else {
                        // Get image dimensions for other formats
                        $imageInfo = getimagesize($imagePath);
                        if ($imageInfo) {
                            $image['width'] = $imageInfo[0];
                            $image['height'] = $imageInfo[1];
                            $image['dimensions'] = $imageInfo[0] . 'x' . $imageInfo[1];
                            $image['mime_type'] = $imageInfo['mime'];
                        }
                    }
                }
            }
            
            return $this->success(['images' => $images]);
        } catch (Exception $e) {
            return $this->error('Error getting images: ' . $e->getMessage());
        }
    }
    
    private function uploadImages() {
        try {
            if (!isset($_FILES['images']) || empty($_FILES['images']['name'][0])) {
                return $this->error('No images uploaded');
            }
            
            $uploadDir = __DIR__ . '/../public/assets/img/';
            
            // Create directory if it doesn't exist
            if (!is_dir($uploadDir)) {
                if (!mkdir($uploadDir, 0777, true)) {
                    return $this->error('Failed to create upload directory');
                }
            }
            
            $uploadedImages = [];
            $errors = [];
            $allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/svg+xml'];
            $maxFileSize = 5 * 1024 * 1024; // 5MB
            
            // Handle multiple file uploads
            $fileCount = count($_FILES['images']['name']);
            
            for ($i = 0; $i < $fileCount; $i++) {
                $fileName = $_FILES['images']['name'][$i];
                $fileTmpName = $_FILES['images']['tmp_name'][$i];
                $fileSize = $_FILES['images']['size'][$i];
                $fileError = $_FILES['images']['error'][$i];
                $fileType = $_FILES['images']['type'][$i];
                
                // Skip empty files
                if (empty($fileName)) {
                    continue;
                }
                
                // Check for upload errors
                if ($fileError !== UPLOAD_ERR_OK) {
                    $errors[] = "Upload error for {$fileName}: " . $this->getUploadErrorMessage($fileError);
                    continue;
                }
                
                // Validate file type
                if (!in_array($fileType, $allowedTypes)) {
                    $errors[] = "Invalid file type for {$fileName}. Allowed: JPG, PNG, GIF, WebP, SVG";
                    continue;
                }
                
                // Validate file size
                if ($fileSize > $maxFileSize) {
                    $errors[] = "File {$fileName} is too large. Maximum size: 5MB";
                    continue;
                }
                
                // Generate safe filename
                $fileExtension = strtolower(pathinfo($fileName, PATHINFO_EXTENSION));
                $safeName = $this->generateSafeFileName($fileName, $fileExtension);
                $targetPath = $uploadDir . $safeName;
                
                // Check if file already exists and generate unique name
                $counter = 1;
                $originalSafeName = $safeName;
                while (file_exists($targetPath)) {
                    $nameWithoutExt = pathinfo($originalSafeName, PATHINFO_FILENAME);
                    $safeName = $nameWithoutExt . '_' . $counter . '.' . $fileExtension;
                    $targetPath = $uploadDir . $safeName;
                    $counter++;
                }
                
                // Move uploaded file
                if (move_uploaded_file($fileTmpName, $targetPath)) {
                    try {
                        // Save to database
                        $this->execute(
                            "INSERT INTO images (name) VALUES (?)",
                            [$safeName]
                        );
                        
                        $uploadedImages[] = [
                            'name' => $safeName,
                            'original_name' => $fileName,
                            'path' => '/public/assets/img/' . $safeName,
                            'size' => $fileSize,
                            'size_formatted' => $this->formatFileSize($fileSize)
                        ];
                    } catch (Exception $e) {
                        // If database save fails, remove the uploaded file
                        if (file_exists($targetPath)) {
                            unlink($targetPath);
                        }
                        $errors[] = "Database error for {$fileName}: " . $e->getMessage();
                    }
                } else {
                    $errors[] = "Failed to move uploaded file: {$fileName}";
                }
            }
            
            $result = [
                'message' => count($uploadedImages) . ' image(s) uploaded successfully',
                'uploaded' => $uploadedImages
            ];
            
            if (!empty($errors)) {
                $result['errors'] = $errors;
            }
            
            return $this->success($result);
            
        } catch (Exception $e) {
            return $this->error('Error uploading images: ' . $e->getMessage());
        }
    }
    
    private function deleteImage() {
        $id = $_GET['id'] ?? $_POST['id'] ?? '';
        if (!$id) {
            return $this->error('Image ID required');
        }
        
        try {
            // Get image info
            $image = $this->queryAll(
                "SELECT * FROM images WHERE id = ?",
                [$id]
            )[0] ?? null;
            
            if (!$image) {
                return $this->error('Image not found');
            }
            
            // Delete file from filesystem
            $filePath = __DIR__ . '/../public/assets/img/' . $image['name'];
            if (file_exists($filePath)) {
                if (!unlink($filePath)) {
                    return $this->error('Failed to delete image file');
                }
            }
            
            // Delete from database
            $this->execute("DELETE FROM images WHERE id = ?", [$id]);
            
            return $this->success(['message' => 'Image deleted successfully']);
        } catch (Exception $e) {
            return $this->error('Error deleting image: ' . $e->getMessage());
        }
    }
    
    // Helper methods for image management
    private function generateSafeFileName($originalName, $extension) {
        // Remove extension from original name
        $nameWithoutExt = pathinfo($originalName, PATHINFO_FILENAME);
        
        // Keep original name but make it safe for filesystem
        $safeName = $nameWithoutExt;
        
        // Replace problematic characters with underscores
        $safeName = preg_replace('/[^a-zA-Z0-9\-_\. ]/', '_', $safeName);
        
        // Replace multiple underscores/spaces with single underscore
        $safeName = preg_replace('/[_\s]+/', '_', $safeName);
        
        // Remove leading/trailing underscores
        $safeName = trim($safeName, '_');
        
        // If name is empty after cleaning, use a default
        if (empty($safeName)) {
            $safeName = 'image';
        }
        
        return $safeName . '.' . $extension;
    }
    
    private function formatFileSize($bytes) {
        if ($bytes >= 1048576) {
            return number_format($bytes / 1048576, 2) . ' MB';
        } elseif ($bytes >= 1024) {
            return number_format($bytes / 1024, 2) . ' KB';
        } else {
            return $bytes . ' Bytes';
        }
    }
    
    private function getUploadErrorMessage($errorCode) {
        switch ($errorCode) {
            case UPLOAD_ERR_INI_SIZE:
                return 'File exceeds upload_max_filesize directive';
            case UPLOAD_ERR_FORM_SIZE:
                return 'File exceeds MAX_FILE_SIZE directive';
            case UPLOAD_ERR_PARTIAL:
                return 'File was only partially uploaded';
            case UPLOAD_ERR_NO_FILE:
                return 'No file was uploaded';
            case UPLOAD_ERR_NO_TMP_DIR:
                return 'Missing temporary folder';
            case UPLOAD_ERR_CANT_WRITE:
                return 'Failed to write file to disk';
            case UPLOAD_ERR_EXTENSION:
                return 'File upload stopped by extension';
            default:
                return 'Unknown upload error';
        }
    }
    
    /**
     * Extract dimensions from SVG file
     */
    private function getSvgDimensions($filePath) {
        try {
            if (!file_exists($filePath)) {
                return null;
            }
            
            $svgContent = file_get_contents($filePath);
            if ($svgContent === false) {
                return null;
            }
            
            // Try to parse SVG with SimpleXML
            $previousErrors = libxml_use_internal_errors(true);
            $svg = simplexml_load_string($svgContent);
            libxml_use_internal_errors($previousErrors);
            
            if ($svg === false) {
                return null;
            }
            
            $width = null;
            $height = null;
            
            // Get width and height attributes
            if (isset($svg['width'])) {
                $width = $this->parseSvgDimension((string)$svg['width']);
            }
            if (isset($svg['height'])) {
                $height = $this->parseSvgDimension((string)$svg['height']);
            }
            
            // If no width/height, try viewBox
            if (($width === null || $height === null) && isset($svg['viewBox'])) {
                $viewBox = explode(' ', trim((string)$svg['viewBox']));
                if (count($viewBox) >= 4) {
                    $width = $width ?: (float)$viewBox[2];
                    $height = $height ?: (float)$viewBox[3];
                }
            }
            
            if ($width !== null && $height !== null) {
                return [
                    'width' => (int)$width,
                    'height' => (int)$height
                ];
            }
            
            return null;
        } catch (Exception $e) {
            return null;
        }
    }
    
    /**
     * Parse SVG dimension value (removes units like px, em, etc.)
     */
    private function parseSvgDimension($value) {
        // Remove units and return numeric value
        return (float)preg_replace('/[^0-9.-]/', '', $value);
    }
    
    // ========================================
    // OFFER MANAGEMENT METHODS
    // ========================================
    
    /**
     * Get all offers with optional filtering
     */
    private function getOffers() {
        try {
            require_once __DIR__ . '/../src/Models/Offer.php';
            $offerModel = new \DSAllround\Models\Offer($this->db);
            
            $filters = [
                'status' => $_GET['status'] ?? null,
                'service_id' => $_GET['service_id'] ?? null,
                'date_from' => $_GET['date_from'] ?? null,
                'date_to' => $_GET['date_to'] ?? null,
                'search' => $_GET['search'] ?? null,
                'limit' => $_GET['limit'] ?? 50
            ];
            
            $offers = $offerModel->searchOffers($filters);
            
            // Add formatted status badges
            foreach ($offers as &$offer) {
                $offer['status_badge'] = $offerModel->getStatusBadge((int)$offer['status']);
                $offer['status_text'] = $offerModel->getStatusText((int)$offer['status']);
            }
            
            return $this->success([
                'offers' => $offers,
                'total' => count($offers)
            ]);
            
        } catch (Exception $e) {
            return $this->error('Failed to fetch offers: ' . $e->getMessage());
        }
    }
    
    /**
     * Get detailed information about a specific offer
     */
    private function getOfferDetails() {
        $offerId = (int)($_GET['id'] ?? 0);
        
        if (!$offerId) {
            return $this->error('Offer ID required');
        }
        
        try {
            require_once __DIR__ . '/../src/Models/Offer.php';
            $offerModel = new \DSAllround\Models\Offer($this->db);
            
            $offer = $offerModel->getOfferById($offerId);
            
            if (!$offer) {
                return $this->error('Offer not found');
            }
            
            $offer['status_badge'] = $offerModel->getStatusBadge((int)$offer['status']);
            $offer['status_text'] = $offerModel->getStatusText((int)$offer['status']);
            
            return $this->success(['offer' => $offer]);
            
        } catch (Exception $e) {
            return $this->error('Failed to fetch offer details: ' . $e->getMessage());
        }
    }
    
    /**
     * Get all offers for a specific submission
     */
    private function getSubmissionOffers() {
        $submissionId = (int)($_GET['submission_id'] ?? 0);
        
        if (!$submissionId) {
            return $this->error('Submission ID required');
        }
        
        try {
            require_once __DIR__ . '/../src/Models/Offer.php';
            $offerModel = new \DSAllround\Models\Offer($this->db);
            
            $offers = $offerModel->getOffersBySubmission($submissionId);
            
            // Debug logging
            if ($this->debug) {
                error_log("getSubmissionOffers Debug - Raw offers from DB: " . json_encode($offers));
            }
            
            // Add formatted status badges
            foreach ($offers as &$offer) {
                // Debug each offer
                if ($this->debug) {
                    error_log("Processing offer ID: " . ($offer['id'] ?? 'NULL') . " for submission $submissionId");
                }
                
                $offer['status_badge'] = $offerModel->getStatusBadge((int)$offer['status']);
                $offer['status_text'] = $offerModel->getStatusText((int)$offer['status']);
                $offer['formatted_date'] = date('d.m.Y H:i', strtotime($offer['created_at']));
                $offer['formatted_total'] = number_format($offer['total_gross'], 2, ',', '.') . ' €';
            }
            
            // Final debug
            if ($this->debug) {
                error_log("getSubmissionOffers Debug - Final offers array: " . json_encode($offers));
            }
            
            return $this->success(['offers' => $offers]);
            
        } catch (Exception $e) {
            return $this->error('Failed to fetch submission offers: ' . $e->getMessage());
        }
    }
    
    /**
     * Update offer status
     */
    private function updateOfferStatus() {
        $offerId = (int)($_POST['offer_id'] ?? 0);
        $statusRaw = $_POST['status'] ?? null;
        
        // Debug logging
        if ($this->debug) {
            error_log("UpdateOfferStatus Debug - POST data: " . json_encode($_POST));
            error_log("UpdateOfferStatus Debug - offer_id: $offerId, status_raw: $statusRaw");
        }
        
        // Check if status is provided and is numeric
        if (!$offerId || $statusRaw === null || $statusRaw === '') {
            $debugInfo = $this->debug ? " (DEBUG: offerId=$offerId, status_raw='$statusRaw', POST=" . json_encode($_POST) . ")" : "";
            return $this->error('Invalid parameters: offer_id and status required' . $debugInfo);
        }
        
        $status = (int)$statusRaw;
        
        // Additional validation for status range
        if ($status < 0 || $status > 4) {
            return $this->error("Invalid status value: $status (must be 0-4)");
        }
        
        // Validate status
        $validStatuses = [0, 1, 2, 3, 4]; // draft, sent, accepted, declined, expired
        if (!in_array($status, $validStatuses)) {
            return $this->error('Invalid status value');
        }
        
        try {
            require_once __DIR__ . '/../src/Models/Offer.php';
            $offerModel = new \DSAllround\Models\Offer($this->db);
            
            $success = $offerModel->updateOfferStatus($offerId, $status);
            
            if ($success) {
                $statusText = $offerModel->getStatusText($status);
                return $this->success([
                    'message' => "Angebotsstatus auf '{$statusText}' aktualisiert",
                    'status_text' => $statusText,
                    'status_badge' => $offerModel->getStatusBadge($status)
                ]);
            } else {
                return $this->error('Failed to update offer status');
            }
            
        } catch (Exception $e) {
            return $this->error('Failed to update offer status: ' . $e->getMessage());
        }
    }
    
    // ========================================
    // ARCHIVE VIEW METHODS (using existing tables)
    // ========================================
    
    /**
     * Get archived submissions (older than 30 days from existing tables)
     */
    private function getArchivedSubmissions() {
        try {
            $daysOld = (int)($_GET['days'] ?? 30);
            $search = $_GET['search'] ?? '';
            $serviceId = $_GET['service_id'] ?? null;
            $status = $_GET['status'] ?? '';
            $limit = (int)($_GET['limit'] ?? 100);
            
            // Calculate cutoff date
            $cutoffDate = date('Y-m-d H:i:s', strtotime("-{$daysOld} days"));
            $dateCondition = "qs.submitted_at < ?";
            
            $sql = "SELECT qs.*, s.name as service_name,
                           COUNT(o.id) as offers_count,
                           SUM(o.total_gross) as total_offers_value
                    FROM questionnaire_submissions qs
                    LEFT JOIN services s ON qs.service_id = s.id
                    LEFT JOIN offers o ON qs.id = o.submission_id
                    WHERE {$dateCondition}";
            
            $params = [$cutoffDate];
            
            // Add filters
            if (!empty($search)) {
                $sql .= " AND (qs.contact_name LIKE ? OR qs.reference LIKE ? OR qs.contact_email LIKE ?)";
                $searchTerm = '%' . $search . '%';
                $params[] = $searchTerm;
                $params[] = $searchTerm;
                $params[] = $searchTerm;
            }
            
            if (!empty($serviceId)) {
                $sql .= " AND qs.service_id = ?";
                $params[] = $serviceId;
            }
            
            if (!empty($status)) {
                $sql .= " AND qs.status = ?";
                $params[] = $status;
            }
            
            $sql .= " GROUP BY qs.id ORDER BY qs.submitted_at DESC LIMIT ?";
            $params[] = $limit;
            
            $stmt = $this->db->prepare($sql);
            $stmt->execute($params);
            $submissions = $stmt->fetchAll(\PDO::FETCH_ASSOC);
            
            // Format the results
            foreach ($submissions as &$submission) {
                $submission['is_archived'] = true;
                $submission['days_old'] = floor((time() - strtotime($submission['submitted_at'])) / (24 * 3600));
                $submission['formatted_date'] = date('d.m.Y H:i', strtotime($submission['submitted_at']));
                $submission['formatted_offers_value'] = number_format($submission['total_offers_value'] ?? 0, 2, ',', '.') . ' €';
            }
            
            return $this->success([
                'submissions' => $submissions,
                'total' => count($submissions),
                'cutoff_date' => $cutoffDate,
                'days_old' => $daysOld
            ]);
            
        } catch (Exception $e) {
            return $this->error('Failed to get archived submissions: ' . $e->getMessage());
        }
    }
    
    /**
     * Get archive statistics from existing tables
     */
    private function getArchiveStats() {
        try {
            $daysOld = (int)($_GET['days'] ?? 30);
            $cutoffDate = date('Y-m-d H:i:s', strtotime("-{$daysOld} days"));
            
            // Get archived submissions count
            $stmt = $this->db->prepare(
                "SELECT COUNT(*) as archived_submissions,
                        MIN(submitted_at) as oldest_submission,
                        MAX(submitted_at) as newest_archived
                 FROM questionnaire_submissions 
                 WHERE submitted_at < ?"
            );
            $stmt->execute([$cutoffDate]);
            $submissionStats = $stmt->fetch(\PDO::FETCH_ASSOC);
            
            // Get archived offers stats
            $stmt = $this->db->prepare(
                "SELECT COUNT(o.id) as archived_offers,
                        SUM(o.total_gross) as total_archived_value,
                        COUNT(DISTINCT o.submission_id) as submissions_with_offers
                 FROM offers o
                 JOIN questionnaire_submissions qs ON o.submission_id = qs.id
                 WHERE qs.submitted_at < ?"
            );
            $stmt->execute([$cutoffDate]);
            $offerStats = $stmt->fetch(\PDO::FETCH_ASSOC);
            
            // Get stats by service
            $stmt = $this->db->prepare(
                "SELECT s.name as service_name,
                        COUNT(qs.id) as submissions_count,
                        COUNT(o.id) as offers_count,
                        SUM(o.total_gross) as service_value
                 FROM questionnaire_submissions qs
                 LEFT JOIN services s ON qs.service_id = s.id
                 LEFT JOIN offers o ON qs.id = o.submission_id
                 WHERE qs.submitted_at < ?
                 GROUP BY qs.service_id, s.name
                 ORDER BY submissions_count DESC"
            );
            $stmt->execute([$cutoffDate]);
            $serviceStats = $stmt->fetchAll(\PDO::FETCH_ASSOC);
            
            // Get stats by status
            $stmt = $this->db->prepare(
                "SELECT status,
                        COUNT(*) as count
                 FROM questionnaire_submissions
                 WHERE submitted_at < ?
                 GROUP BY status"
            );
            $stmt->execute([$cutoffDate]);
            $statusStats = $stmt->fetchAll(\PDO::FETCH_ASSOC);
            
            return $this->success([
                'summary' => array_merge($submissionStats, $offerStats),
                'by_service' => $serviceStats,
                'by_status' => $statusStats,
                'cutoff_date' => $cutoffDate,
                'days_old' => $daysOld
            ]);
            
        } catch (Exception $e) {
            return $this->error('Failed to get archive stats: ' . $e->getMessage());
        }
    }
    
    /**
     * Restore archived submission to current list
     */
    private function restoreSubmission() {
        try {
            $submissionId = $_POST['id'] ?? $_GET['id'] ?? null;
            
            if (!$submissionId || !is_numeric($submissionId)) {
                return $this->error('Ungültige Submissions-ID');
            }
            
            // Get current submission data
            $stmt = $this->db->prepare(
                "SELECT id, status, submitted_at, customer_name, reference FROM questionnaire_submissions WHERE id = ?"
            );
            $stmt->execute([$submissionId]);
            $submission = $stmt->fetch(\PDO::FETCH_ASSOC);
            
            if (!$submission) {
                return $this->error('Submission nicht gefunden');
            }
            
            // Check if submission is actually archived (> 30 days and completed)
            $submittedDate = new \DateTime($submission['submitted_at']);
            $now = new \DateTime();
            $daysDiff = $now->diff($submittedDate)->days;
            
            if ($daysDiff <= 30) {
                return $this->error('Diese Submission ist nicht archiviert (weniger als 30 Tage alt)');
            }
            
            if ($submission['status'] !== 'abgeschlossen') {
                return $this->error('Diese Submission ist bereits in der aktuellen Liste (Status nicht abgeschlossen)');
            }
            
            // Update status from "abgeschlossen" to "in_bearbeitung"
            $restoredAt = date('Y-m-d H:i:s');
            $restoreNote = "\nWiederhergestellt am: {$restoredAt} (Status geändert von abgeschlossen zu in_bearbeitung)";
            
            $stmt = $this->db->prepare(
                "UPDATE questionnaire_submissions 
                 SET status = 'in_bearbeitung',
                     processed_at = ?,
                     internal_notes = CASE 
                         WHEN internal_notes IS NULL OR internal_notes = '' THEN ?
                         ELSE internal_notes || ?
                     END
                 WHERE id = ?"
            );
            $stmt->execute([$restoredAt, $restoreNote, $restoreNote, $submissionId]);
            
            // Get updated submission data
            $stmt = $this->db->prepare(
                "SELECT qs.*, s.name as service_name
                 FROM questionnaire_submissions qs
                 LEFT JOIN services s ON qs.service_id = s.id
                 WHERE qs.id = ?"
            );
            $stmt->execute([$submissionId]);
            $updatedSubmission = $stmt->fetch(\PDO::FETCH_ASSOC);
            
            return $this->success([
                'submission' => $updatedSubmission,
                'message' => "Anfrage '{$submission['reference']}' wurde erfolgreich wiederhergestellt"
            ]);
            
        } catch (Exception $e) {
            return $this->error('Fehler beim Wiederherstellen: ' . $e->getMessage());
        }
    }
    
    // ========================================================================
    // Settings Management Methods
    // ========================================================================
    
    /**
     * Get all settings
     */
    private function getSettings() {
        try {
            // Debug session information
            $this->debugLog("getSettings() - Session data: " . print_r($_SESSION, true));
            
            // Check if user is admin to determine which settings to show
            $userRole = $_SESSION['role'] ?? null;
            $isAdmin = ($userRole === 'Admin');
            
            $this->debugLog("getSettings() - User role: $userRole, isAdmin: " . ($isAdmin ? 'true' : 'false'));
            
            // Filter settings based on role - non-admins only see public settings
            if ($isAdmin) {
                // Admins see all settings
                $settings = $this->queryAll("SELECT * FROM settings ORDER BY setting_key ASC");
                $this->debugLog("getSettings() - Admin: Loading all settings, count: " . count($settings));
            } else {
                // Non-admins only see public settings (is_public = 1)
                $settings = $this->queryAll("SELECT * FROM settings WHERE is_public = 1 ORDER BY setting_key ASC");
                $this->debugLog("getSettings() - Non-admin: Loading public settings only, count: " . count($settings));
            }
            
            // Map database field names to consistent frontend field names
            $mappedSettings = array_map(function($setting) {
                return [
                    'id' => $setting['id'],
                    'key' => $setting['setting_key'],
                    'value' => $setting['setting_value'],
                    'type' => $setting['setting_type'],
                    'description' => $setting['description'],
                    'is_public' => $setting['is_public'],
                    'created_at' => $setting['created_at'],
                    'updated_at' => $setting['updated_at']
                ];
            }, $settings);
            
            $this->debugLog("getSettings() - Returning " . count($mappedSettings) . " settings");
            
            return $this->success([
                'settings' => $mappedSettings,
                'userRole' => $userRole,
                'isAdmin' => $isAdmin,
                'debug' => [
                    'sessionData' => $_SESSION,
                    'settingsCount' => count($mappedSettings)
                ]
            ]);
        } catch (Exception $e) {
            $this->debugLog("getSettings() - Error: " . $e->getMessage());
            return $this->error('Fehler beim Laden der Einstellungen: ' . $e->getMessage());
        }
    }
    
    /**
     * Get a single setting by ID or key
     */
    private function getSetting() {
        $id = $_GET['id'] ?? null;
        $key = $_GET['key'] ?? null;
        
        if (!$id && !$key) {
            return $this->error('Setting ID oder Key ist erforderlich');
        }
        
        try {
            if ($id) {
                $setting = $this->queryAll("SELECT * FROM settings WHERE id = ?", [$id])[0] ?? null;
            } else {
                $setting = $this->queryAll("SELECT * FROM settings WHERE setting_key = ?", [$key])[0] ?? null;
            }
            
            if (!$setting) {
                return $this->error('Setting nicht gefunden');
            }
            
            // Map database field names to consistent frontend field names
            $mappedSetting = [
                'id' => $setting['id'],
                'key' => $setting['setting_key'],
                'value' => $setting['setting_value'],
                'type' => $setting['setting_type'],
                'description' => $setting['description'],
                'is_public' => $setting['is_public'],
                'created_at' => $setting['created_at'],
                'updated_at' => $setting['updated_at']
            ];
            
            return $this->success(['setting' => $mappedSetting]);
        } catch (Exception $e) {
            return $this->error('Fehler beim Laden der Einstellung: ' . $e->getMessage());
        }
    }
    
    /**
     * Get VAT setting specifically for frontend calculations
     */
    private function getVATSetting() {
        try {
            $setting = $this->queryAll("SELECT setting_value FROM settings WHERE setting_key = 'office_company_has_VAT'")[0] ?? null;
            
            $hasVAT = false;
            if ($setting) {
                $hasVAT = ($setting['setting_value'] === '1' || $setting['setting_value'] === 'true' || $setting['setting_value'] === true);
            }
            
            return $this->success([
                'hasVAT' => $hasVAT,
                'vatRate' => $hasVAT ? 0.19 : 0,
                'isKleinunternehmer' => !$hasVAT,
                'rawValue' => $setting['setting_value'] ?? null
            ]);
        } catch (Exception $e) {
            return $this->error('Fehler beim Laden der VAT-Einstellung: ' . $e->getMessage());
        }
    }

    /**
     * Save a single setting
     */
    private function saveSetting() {
        $this->debugLog("saveSetting() called");
        $this->debugLog("POST data: " . print_r($_POST, true));
        
        $id = $_POST['id'] ?? null;
        $key = $_POST['key'] ?? '';
        $value = $_POST['value'] ?? '';
        $type = $_POST['type'] ?? 'string';
        $description = $_POST['description'] ?? '';
        $isPublic = isset($_POST['is_public']) ? (int)$_POST['is_public'] : 0;
        
        $this->debugLog("Parsed values - ID: $id, Key: $key, Type: $type, Public: $isPublic");
        
        if (!$key) {
            $this->debugLog("Error: Missing setting key");
            return $this->error('Setting key ist erforderlich');
        }
        
        // Check if user is admin for admin-only settings
        $userRole = $_SESSION['role'] ?? null;
        $isAdmin = ($userRole === 'Admin');
        
        try {
            // Check if this is an admin-only setting (is_public = 0)
            if ($id) {
                $existingSetting = $this->queryAll("SELECT is_public FROM settings WHERE id = ?", [$id])[0] ?? null;
            } else {
                $existingSetting = $this->queryAll("SELECT is_public FROM settings WHERE setting_key = ?", [$key])[0] ?? null;
            }
            
            // If setting exists and is admin-only, check permissions
            if ($existingSetting && $existingSetting['is_public'] == 0 && !$isAdmin) {
                $this->debugLog("Error: Non-admin trying to modify admin-only setting");
                return $this->error('Sie haben keine Berechtigung, diese Einstellung zu bearbeiten');
            }
            
            // If creating new admin-only setting, check permissions
            if (!$existingSetting && $isPublic == 0 && !$isAdmin) {
                $this->debugLog("Error: Non-admin trying to create admin-only setting");
                return $this->error('Sie haben keine Berechtigung, Admin-only Einstellungen zu erstellen');
            }
            
            // Validate the value based on type
            $validatedValue = $this->validateSettingValue($value, $type);
            if ($validatedValue === false) {
                $this->debugLog("Error: Invalid value for type $type: $value");
                return $this->error("Ungültiger Wert für Typ '$type'");
            }
            
            $this->debugLog("Validated value: $validatedValue");
            
            if ($id) {
                $this->debugLog("Updating existing setting by ID: $id");
                // Update existing setting by ID
                $result = $this->execute(
                    "UPDATE settings SET setting_key = ?, setting_value = ?, setting_type = ?, description = ?, is_public = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?",
                    [$key, $validatedValue, $type, $description, $isPublic, $id]
                );
                $this->debugLog("Update result: " . ($result ? 'success' : 'failed'));
                $message = 'Einstellung wurde aktualisiert';
            } else {
                // Check if setting exists by key
                $existingSettingCheck = $this->queryAll("SELECT id FROM settings WHERE setting_key = ?", [$key])[0] ?? null;
                
                if ($existingSettingCheck) {
                    $this->debugLog("Updating existing setting by key: $key");
                    // Update existing setting by key
                    $result = $this->execute(
                        "UPDATE settings SET setting_value = ?, setting_type = ?, description = ?, is_public = ?, updated_at = CURRENT_TIMESTAMP WHERE setting_key = ?",
                        [$validatedValue, $type, $description, $isPublic, $key]
                    );
                    $this->debugLog("Update result: " . ($result ? 'success' : 'failed'));
                    $message = 'Einstellung wurde aktualisiert';
                } else {
                    $this->debugLog("Creating new setting: $key");
                    // Create new setting
                    $result = $this->execute(
                        "INSERT INTO settings (setting_key, setting_value, setting_type, description, is_public) VALUES (?, ?, ?, ?, ?)",
                        [$key, $validatedValue, $type, $description, $isPublic]
                    );
                    $this->debugLog("Insert result: " . ($result ? 'success' : 'failed'));
                    $message = 'Neue Einstellung wurde erstellt';
                }
            }
            
            $this->debugLog("saveSetting() completed successfully: $message");
            return $this->success(['message' => $message]);
        } catch (Exception $e) {
            $this->debugLog("saveSetting() exception: " . $e->getMessage());
            return $this->error('Fehler beim Speichern der Einstellung: ' . $e->getMessage());
        }
    }
    
    /**
     * Save multiple settings at once
     */
    private function saveSettings() {
        $settings = json_decode($_POST['settings'] ?? '[]', true);
        
        if (!is_array($settings) || empty($settings)) {
            return $this->error('Keine gültigen Einstellungen übermittelt');
        }
        
        // Check if user is admin for admin-only settings
        $userRole = $_SESSION['role'] ?? null;
        $isAdmin = ($userRole === 'Admin');
        
        try {
            $this->db->beginTransaction();
            
            $updatedCount = 0;
            foreach ($settings as $setting) {
                if (!isset($setting['key']) || !isset($setting['value'])) {
                    continue;
                }
                
                $key = $setting['key'];
                $value = $setting['value'];
                $type = $setting['type'] ?? 'string';
                $description = $setting['description'] ?? '';
                $isPublic = isset($setting['is_public']) ? (int)$setting['is_public'] : 0;
                
                // Check if this is an admin-only setting
                $existingSetting = $this->queryAll("SELECT is_public FROM settings WHERE setting_key = ?", [$key])[0] ?? null;
                
                // If setting exists and is admin-only, check permissions
                if ($existingSetting && $existingSetting['is_public'] == 0 && !$isAdmin) {
                    $this->db->rollBack();
                    return $this->error("Sie haben keine Berechtigung, die Einstellung '$key' zu bearbeiten");
                }
                
                // If creating new admin-only setting, check permissions
                if (!$existingSetting && $isPublic == 0 && !$isAdmin) {
                    $this->db->rollBack();
                    return $this->error("Sie haben keine Berechtigung, Admin-only Einstellungen zu erstellen");
                }
                
                // Validate the value
                $validatedValue = $this->validateSettingValue($value, $type);
                if ($validatedValue === false) {
                    throw new Exception("Ungültiger Wert für Setting '$key' mit Typ '$type'");
                }
                
                // Update or insert setting
                $result = $this->execute(
                    "INSERT OR REPLACE INTO settings (setting_key, setting_value, setting_type, description, is_public, updated_at) 
                     VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)",
                    [$key, $validatedValue, $type, $description, $isPublic]
                );
                
                if ($result) {
                    $updatedCount++;
                }
            }
            
            $this->db->commit();
            return $this->success([
                'message' => "$updatedCount Einstellungen wurden gespeichert",
                'updated_count' => $updatedCount
            ]);
            
        } catch (Exception $e) {
            $this->db->rollBack();
            return $this->error('Fehler beim Speichern der Einstellungen: ' . $e->getMessage());
        }
    }
    
    /**
     * Validate setting value based on its type
     */
    private function validateSettingValue($value, $type) {
        switch ($type) {
            case 'string':
                return (string)$value;
                
            case 'int':
                if (!is_numeric($value)) {
                    return false;
                }
                return (string)(int)$value;
                
            case 'bool':
                if ($value === 'true' || $value === '1' || $value === 1 || $value === true) {
                    return '1';
                } elseif ($value === 'false' || $value === '0' || $value === 0 || $value === false) {
                    return '0';
                } else {
                    return false;
                }
                
            case 'json':
                if (is_string($value)) {
                    $decoded = json_decode($value, true);
                    if (json_last_error() !== JSON_ERROR_NONE) {
                        return false;
                    }
                    return $value;
                } elseif (is_array($value) || is_object($value)) {
                    return json_encode($value);
                } else {
                    return false;
                }
                
            default:
                return (string)$value;
        }
    }
    
    /**
     * Get public settings (for frontend use)
     */
    private function getPublicSettings() {
        try {
            $settings = $this->queryAll("SELECT setting_key, setting_value, setting_type FROM settings WHERE is_public = 1 ORDER BY setting_key ASC");
            
            $result = [];
            foreach ($settings as $setting) {
                $key = $setting['setting_key'];
                $value = $setting['setting_value'];
                $type = $setting['setting_type'];
                
                // Convert value based on type
                switch ($type) {
                    case 'int':
                        $result[$key] = (int)$value;
                        break;
                    case 'bool':
                        $result[$key] = (bool)$value;
                        break;
                    case 'json':
                        $result[$key] = json_decode($value, true);
                        break;
                    default:
                        $result[$key] = $value;
                }
            }
            
            return $this->success(['settings' => $result]);
        } catch (Exception $e) {
            return $this->error('Fehler beim Laden der öffentlichen Einstellungen: ' . $e->getMessage());
        }
    }
    
    // ========================================================================
    // User Management Methods
    // ========================================================================
    
    private function createUser() {
        try {
            // Check permissions
            if (!$this->hasPermission('users_manage')) {
                return $this->error('Keine Berechtigung zur Benutzerverwaltung');
            }
            
            $username = trim($_POST['username'] ?? '');
            $email = trim($_POST['email'] ?? '');
            $firstName = trim($_POST['first_name'] ?? '');
            $lastName = trim($_POST['last_name'] ?? '');
            $role = $_POST['role'] ?? 'Mitarbeiter';
            $password = $_POST['password'] ?? '';
            $isActive = (int)($_POST['is_active'] ?? 1);
            
            // Check if trying to create Admin account - only Admins can do this
            if ($role === 'Admin' && ($_SESSION['role'] ?? '') !== 'Admin') {
                return $this->error('Nur Admins können Admin-Accounts erstellen');
            }
            
            // Validate required fields
            if (empty($username) || empty($email) || empty($password)) {
                return $this->error('Benutzername, E-Mail und Passwort sind erforderlich');
            }
            
            // Validate email format
            if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
                return $this->error('Ungültige E-Mail-Adresse');
            }
            
            // Check if username already exists
            $stmt = $this->db->prepare("SELECT id FROM users WHERE username = ?");
            $stmt->execute([$username]);
            if ($stmt->fetch()) {
                return $this->error('Benutzername bereits vergeben');
            }
            
            // Check if email already exists
            $stmt = $this->db->prepare("SELECT id FROM users WHERE email = ?");
            $stmt->execute([$email]);
            if ($stmt->fetch()) {
                return $this->error('E-Mail-Adresse bereits vergeben');
            }
            
            // Hash password
            $passwordHash = password_hash($password, PASSWORD_DEFAULT);
            
            // Insert new user
            $stmt = $this->db->prepare("
                INSERT INTO users (username, email, password_hash, first_name, last_name, 
                                  role, is_active, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
            ");
            
            $stmt->execute([
                $username, $email, $passwordHash, $firstName, $lastName, 
                $role, $isActive
            ]);
            
            return $this->success([
                'message' => 'Benutzer erfolgreich erstellt',
                'userId' => $this->db->lastInsertId()
            ]);
            
        } catch (Exception $e) {
            return $this->error('Fehler beim Erstellen des Benutzers: ' . $e->getMessage());
        }
    }
    
    private function updateUser() {
        try {
            // Check permissions
            if (!$this->hasPermission('users_manage')) {
                return $this->error('Keine Berechtigung zur Benutzerverwaltung');
            }
            
            $userId = (int)($_POST['userId'] ?? 0);
            $username = trim($_POST['username'] ?? '');
            $email = trim($_POST['email'] ?? '');
            $firstName = trim($_POST['first_name'] ?? '');
            $lastName = trim($_POST['last_name'] ?? '');
            $role = $_POST['role'] ?? 'Mitarbeiter';
            $password = $_POST['password'] ?? '';
            $isActive = (int)($_POST['is_active'] ?? 1);
            
            if (!$userId) {
                return $this->error('Benutzer-ID erforderlich');
            }
            
            // Check if trying to edit Admin account or set Admin role - only Admins can do this
            $stmt = $this->db->prepare("SELECT role FROM users WHERE id = ?");
            $stmt->execute([$userId]);
            $currentUserRole = $stmt->fetchColumn();
            
            $currentLoggedInRole = $_SESSION['role'] ?? '';
            
            if ($currentUserRole === 'Admin' && $currentLoggedInRole !== 'Admin') {
                return $this->error('Nur Admins können Admin-Accounts bearbeiten');
            }
            
            if ($role === 'Admin' && $currentLoggedInRole !== 'Admin') {
                return $this->error('Nur Admins können Admin-Rollen vergeben');
            }
            
            // Validate required fields
            if (empty($username) || empty($email)) {
                return $this->error('Benutzername und E-Mail sind erforderlich');
            }
            
            // Validate email format
            if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
                return $this->error('Ungültige E-Mail-Adresse');
            }
            
            // Check if username already exists (excluding current user)
            $stmt = $this->db->prepare("SELECT id FROM users WHERE username = ? AND id != ?");
            $stmt->execute([$username, $userId]);
            if ($stmt->fetch()) {
                return $this->error('Benutzername bereits vergeben');
            }
            
            // Check if email already exists (excluding current user)
            $stmt = $this->db->prepare("SELECT id FROM users WHERE email = ? AND id != ?");
            $stmt->execute([$email, $userId]);
            if ($stmt->fetch()) {
                return $this->error('E-Mail-Adresse bereits vergeben');
            }
            
            // Prepare update query
            if (!empty($password)) {
                // Update with new password
                $passwordHash = password_hash($password, PASSWORD_DEFAULT);
                $stmt = $this->db->prepare("
                    UPDATE users 
                    SET username = ?, email = ?, password_hash = ?, first_name = ?, 
                        last_name = ?, role = ?, is_active = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE id = ?
                ");
                $stmt->execute([
                    $username, $email, $passwordHash, $firstName, $lastName, 
                    $role, $isActive, $userId
                ]);
            } else {
                // Update without changing password
                $stmt = $this->db->prepare("
                    UPDATE users 
                    SET username = ?, email = ?, first_name = ?, last_name = ?, 
                        role = ?, is_active = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE id = ?
                ");
                $stmt->execute([
                    $username, $email, $firstName, $lastName, 
                    $role, $isActive, $userId
                ]);
            }
            
            return $this->success([
                'message' => 'Benutzer erfolgreich aktualisiert'
            ]);
            
        } catch (Exception $e) {
            return $this->error('Fehler beim Aktualisieren des Benutzers: ' . $e->getMessage());
        }
    }
    
    private function resetUserPassword() {
        try {
            // Check permissions
            if (!$this->hasPermission('users_manage')) {
                return $this->error('Keine Berechtigung zur Benutzerverwaltung');
            }
            
            $userId = (int)($_POST['userId'] ?? 0);
            
            if (!$userId) {
                return $this->error('Benutzer-ID erforderlich');
            }
            
            // Check if trying to reset Admin password - only Admins can do this
            $stmt = $this->db->prepare("SELECT role FROM users WHERE id = ?");
            $stmt->execute([$userId]);
            $targetUserRole = $stmt->fetchColumn();
            
            if ($targetUserRole === 'Admin' && ($_SESSION['role'] ?? '') !== 'Admin') {
                return $this->error('Nur Admins können Admin-Passwörter zurücksetzen');
            }
            
            // Generate temporary password
            $tempPassword = $this->generateTempPassword();
            $passwordHash = password_hash($tempPassword, PASSWORD_DEFAULT);
            
            // Update user password and reset login attempts
            $stmt = $this->db->prepare("
                UPDATE users 
                SET password_hash = ?, login_attempts = 0, locked_until = NULL, 
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
            ");
            $stmt->execute([$passwordHash, $userId]);
            
            // Deactivate all user sessions
            $stmt = $this->db->prepare("UPDATE user_sessions SET is_active = 0 WHERE user_id = ?");
            $stmt->execute([$userId]);
            
            return $this->success([
                'message' => 'Passwort erfolgreich zurückgesetzt',
                'newPassword' => $tempPassword
            ]);
            
        } catch (Exception $e) {
            return $this->error('Fehler beim Zurücksetzen des Passworts: ' . $e->getMessage());
        }
    }
    
    private function toggleUserStatus() {
        try {
            // Check permissions
            if (!$this->hasPermission('users_manage')) {
                return $this->error('Keine Berechtigung zur Benutzerverwaltung');
            }
            
            $userId = (int)($_POST['userId'] ?? 0);
            $status = (int)($_POST['status'] ?? 0);
            
            if (!$userId) {
                return $this->error('Benutzer-ID erforderlich');
            }
            
            // Check if trying to modify Admin account - only Admins can do this
            $stmt = $this->db->prepare("SELECT role FROM users WHERE id = ?");
            $stmt->execute([$userId]);
            $targetUserRole = $stmt->fetchColumn();
            
            if ($targetUserRole === 'Admin' && ($_SESSION['role'] ?? '') !== 'Admin') {
                return $this->error('Nur Admins können Admin-Accounts deaktivieren');
            }
            
            // Update user status
            $stmt = $this->db->prepare("
                UPDATE users 
                SET is_active = ?, updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
            ");
            $stmt->execute([$status, $userId]);
            
            // If deactivating user, also deactivate all sessions
            if (!$status) {
                $stmt = $this->db->prepare("UPDATE user_sessions SET is_active = 0 WHERE user_id = ?");
                $stmt->execute([$userId]);
            }
            
            $statusText = $status ? 'aktiviert' : 'deaktiviert';
            
            return $this->success([
                'message' => "Benutzer erfolgreich $statusText"
            ]);
            
        } catch (Exception $e) {
            return $this->error('Fehler beim Ändern des Benutzerstatus: ' . $e->getMessage());
        }
    }
    
    private function generateTempPassword() {
        $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%';
        $password = '';
        for ($i = 0; $i < 12; $i++) {
            $password .= $chars[random_int(0, strlen($chars) - 1)];
        }
        return $password;
    }
    
    /**
     * Change user password
     * Allows users to change their own password
     */
    private function changePassword() {
        error_log('🔐 changePassword() called');
        try {
            // Check if user is authenticated
            if (!isset($_SESSION['user_id'])) {
                error_log('❌ User not authenticated');
                return $this->error('Benutzer nicht authentifiziert');
            }
            error_log('✅ User authenticated: ' . $_SESSION['user_id']);
            
            $userId = $_SESSION['user_id'];
            $input = json_decode(file_get_contents('php://input'), true);
            error_log('📥 Input received: ' . json_encode($input));
            
            $currentPassword = trim($input['currentPassword'] ?? '');
            $newPassword = trim($input['newPassword'] ?? '');
            $confirmPassword = trim($input['confirmPassword'] ?? '');
            error_log('🔑 Passwords lengths: current=' . strlen($currentPassword) . ', new=' . strlen($newPassword) . ', confirm=' . strlen($confirmPassword));
            
            // Validate input
            if (empty($currentPassword)) {
                return $this->error('Aktuelles Passwort ist erforderlich');
            }
            
            if (empty($newPassword)) {
                return $this->error('Neues Passwort ist erforderlich');
            }
            
            if ($newPassword !== $confirmPassword) {
                return $this->error('Neue Passwörter stimmen nicht überein');
            }
            
            // Password strength validation
            if (strlen($newPassword) < 8) {
                return $this->error('Neues Passwort muss mindestens 8 Zeichen lang sein');
            }
            
            if (!preg_match('/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/', $newPassword)) {
                return $this->error('Neues Passwort muss mindestens einen Kleinbuchstaben, einen Großbuchstaben und eine Zahl enthalten');
            }
            
            // Get current user
            $stmt = $this->db->prepare("SELECT username, password_hash FROM users WHERE id = ? AND is_active = 1");
            $stmt->execute([$userId]);
            $user = $stmt->fetch();
            
            if (!$user) {
                return $this->error('Benutzer nicht gefunden');
            }
            
            // Verify current password
            if (!password_verify($currentPassword, $user['password_hash'])) {
                return $this->error('Aktuelles Passwort ist nicht korrekt');
            }
            
            // Check if new password is different from current
            if (password_verify($newPassword, $user['password_hash'])) {
                return $this->error('Neues Passwort muss sich vom aktuellen Passwort unterscheiden');
            }
            
            // Hash new password
            $newPasswordHash = password_hash($newPassword, PASSWORD_DEFAULT);
            
            // Update password
            $stmt = $this->db->prepare("UPDATE users SET password_hash = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?");
            $stmt->execute([$newPasswordHash, $userId]);
            
            // Log activity
            if (method_exists($this, 'logActivity')) {
                $this->logActivity($userId, 'password_changed', json_encode([
                    'username' => $user['username'],
                    'changed_by_self' => true
                ]));
            }
            
            return $this->success([
                'message' => 'Passwort wurde erfolgreich geändert'
            ]);
            
        } catch (\PDOException $e) {
            error_log("Password change error: " . $e->getMessage());
            return $this->error('Fehler beim Ändern des Passworts: ' . $e->getMessage());
        }
    }
    
    private function hasPermission($permission) {
        if (session_status() == PHP_SESSION_NONE) {
            session_start();
        }
        
        // TEMP DEBUG: Log detailed session info
        error_log("🔍 DEBUG: hasPermission('$permission') called");
        error_log("🔍 DEBUG: Session ID: " . session_id());
        error_log("🔍 DEBUG: Session authenticated: " . (isset($_SESSION['authenticated']) ? ($_SESSION['authenticated'] ? 'true' : 'false') : 'NOT SET'));
        error_log("🔍 DEBUG: Session role: " . ($_SESSION['role'] ?? 'NOT SET'));
        error_log("🔍 DEBUG: Session user_id: " . ($_SESSION['user_id'] ?? 'NOT SET'));
        
        if (!isset($_SESSION['authenticated']) || !$_SESSION['authenticated']) {
            error_log('❌ User not authenticated for permission: ' . $permission);
            return false;
        }
        
        $role = $_SESSION['role'] ?? null;
        if (!$role) {
            error_log('❌ No role set for permission: ' . $permission);
            return false;
        }
        
        try {
            $stmt = $this->db->prepare("
                SELECT permission_value 
                FROM user_permissions 
                WHERE role = ? AND permission_key = ?
            ");
            $stmt->execute([$role, $permission]);
            $result = $stmt->fetch();
            
            $hasPermission = $result && $result['permission_value'] == 1;
            error_log('🔐 Permission check result for ' . $permission . ': ' . ($hasPermission ? 'granted' : 'denied'));
            
            return $hasPermission;
        } catch (Exception $e) {
            error_log('❌ Permission check failed: ' . $e->getMessage());
            return false;
        }
    }
    
    /**
     * Ensure company settings exist in database
     */
    private function ensureCompanySettings() {
        try {
            // Check if company settings exist, if not create them based on existing settings
            $requiredSettings = [
                'site_name' => 'DS-Allroundservice',
                'site_description' => 'Ihr zuverlässiger Partner für Haushaltsauflösung, Entrümpelung, Transport und Umzüge',
                'contact_email' => 'info@ds-allroundservice.de', 
                'contact_phone' => '+49 123 456 789',
                'contact_address' => '',
                'business_hours' => '{"monday":"08:00 - 18:00","tuesday":"08:00 - 18:00","wednesday":"08:00 - 18:00","thursday":"08:00 - 18:00","friday":"08:00 - 18:00","saturday":"09:00 - 16:00","sunday":"Geschlossen"}',
                'social_facebook' => '',
                'social_instagram' => '',
                'social_twitter' => '',
                'company_website' => 'www.ds-allroundservice.de'
            ];
            
            foreach ($requiredSettings as $key => $defaultValue) {
                // Check if setting exists
                $existing = $this->query("SELECT setting_value FROM settings WHERE setting_key = ?", [$key]);
                
                if (!$existing) {
                    // Create missing setting
                    $this->query(
                        "INSERT OR IGNORE INTO settings (setting_key, setting_value, setting_type, description, created_at, updated_at) VALUES (?, ?, 'string', ?, datetime('now'), datetime('now'))",
                        [$key, $defaultValue, "Company " . ucfirst(str_replace('_', ' ', $key))]
                    );
                    $this->debugLog("Created missing company setting: $key");
                }
            }
        } catch (Exception $e) {
            $this->debugLog("Error ensuring company settings: " . $e->getMessage());
        }
    }
    
    /**
     * Get all company-related variables from database
     */
    private function getCompanyVariables() {
        // Default fallback values
        $companyData = [
            'company_name' => 'DS-Allroundservice',
            'company_description' => '',
            'company_email' => 'info@ds-allroundservice.de',
            'company_phone' => '+49 123 456 789',
            'company_website' => 'www.ds-allroundservice.de',
            'company_address' => '',
            'business_hours' => 'Montag - Freitag: 08:00 - 18:00 Uhr',
            'social_facebook' => '',
            'social_instagram' => '',
            'social_twitter' => '',
            'admin_url' => ($_SERVER['HTTP_HOST'] ?? 'localhost') . '/admin',
            'website_url' => ($_SERVER['HTTP_HOST'] ?? 'localhost'),
            'current_date' => date('d.m.Y'),
            'current_time' => date('H:i'),
            'current_datetime' => date('d.m.Y H:i')
        ];
        
        try {
            // Load settings from database - use all relevant setting keys
            $settingKeys = [
                'site_name',
                'site_description',
                'contact_email', 
                'contact_phone',
                'contact_address',
                'business_hours',
                'social_facebook',
                'social_instagram',
                'social_twitter',
                'company_website',
                'email_from_name'
            ];
            
            $placeholders = str_repeat('?,', count($settingKeys) - 1) . '?';
            $settings = $this->queryAll(
                "SELECT setting_key, setting_value FROM settings WHERE setting_key IN ($placeholders)",
                $settingKeys
            );
            
            // Process loaded settings
            foreach ($settings as $setting) {
                $key = $setting['setting_key'];
                $value = trim($setting['setting_value'] ?? '');
                
                if (empty($value)) continue; // Skip empty values
                
                // Map database settings to template variables
                switch ($key) {
                    case 'site_name':
                        $companyData['company_name'] = $value;
                        break;
                    case 'site_description':
                        $companyData['company_description'] = $value;
                        break;
                    case 'contact_email':
                        $companyData['company_email'] = $value;
                        break;
                    case 'contact_phone':
                        // Map to ALL phone-related variables
                        $companyData['company_phone'] = $value;
                        $companyData['contact_phone'] = $value;
                        $companyData['phone'] = $value;
                        break;
                    case 'contact_address':
                        $companyData['company_address'] = $value;
                        break;
                    case 'business_hours':
                        // Process business_hours JSON format
                        $companyData['business_hours'] = $this->formatBusinessHours($value);
                        break;
                    case 'company_website':
                        $companyData['company_website'] = $value;
                        break;
                    case 'social_facebook':
                        $companyData['social_facebook'] = $value;
                        break;
                    case 'social_instagram':
                        $companyData['social_instagram'] = $value;
                        break;
                    case 'social_twitter':
                        $companyData['social_twitter'] = $value;
                        break;
                    case 'email_from_name':
                        // Use as company name if not set or is default
                        if (empty($companyData['company_name']) || $companyData['company_name'] === 'DS-Allroundservice') {
                            $companyData['company_name'] = $value;
                        }
                        break;
                    default:
                        // Direct mapping for other keys
                        $companyData[$key] = $value;
                        break;
                }
            }
            
            $this->debugLog("Loaded company variables from database: " . json_encode(array_filter($companyData)));
            
        } catch (Exception $e) {
            $this->debugLog("Error loading company variables: " . $e->getMessage());
            // Return defaults on error
        }
        
        return $companyData;
    }
    
    /**
     * Format business hours from JSON data to readable string
     */
    private function formatBusinessHours($businessHoursValue) {
        // If it's already a formatted string, return as is
        if (!empty($businessHoursValue) && !$this->isJsonString($businessHoursValue)) {
            return $businessHoursValue;
        }
        
        // Try to decode JSON
        $hoursData = json_decode($businessHoursValue, true);
        if (json_last_error() !== JSON_ERROR_NONE || !is_array($hoursData)) {
            // Fallback to original value if not valid JSON
            return $businessHoursValue ?: 'Montag - Freitag: 08:00 - 18:00 Uhr';
        }
        
        $workdays = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'];
        $weekend = ['saturday', 'sunday'];
        $germanDays = [
            'monday' => 'Montag',
            'tuesday' => 'Dienstag', 
            'wednesday' => 'Mittwoch',
            'thursday' => 'Donnerstag',
            'friday' => 'Freitag',
            'saturday' => 'Samstag',
            'sunday' => 'Sonntag'
        ];
        
        // Check if all workdays have the same hours
        $workdayHours = [];
        foreach ($workdays as $day) {
            if (isset($hoursData[$day]) && $hoursData[$day] !== 'Geschlossen' && !empty($hoursData[$day])) {
                $workdayHours[] = $hoursData[$day];
            }
        }
        
        // If all workdays are the same, show compact format
        if (count(array_unique($workdayHours)) === 1 && count($workdayHours) === 5) {
            $weekdayTime = $workdayHours[0];
            
            // Check weekend
            $saturdayHours = $hoursData['saturday'] ?? 'Geschlossen';
            $sundayHours = $hoursData['sunday'] ?? 'Geschlossen';
            
            if ($saturdayHours === 'Geschlossen' && $sundayHours === 'Geschlossen') {
                return "Montag - Freitag: {$weekdayTime}";
            } elseif ($saturdayHours !== 'Geschlossen' && $sundayHours === 'Geschlossen') {
                return "Montag - Freitag: {$weekdayTime}, Samstag: {$saturdayHours}";
            } else {
                return "Montag - Freitag: {$weekdayTime}, Samstag: {$saturdayHours}, Sonntag: {$sundayHours}";
            }
        }
        
        // If not uniform, show individual days
        $formattedHours = [];
        foreach (['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'] as $day) {
            if (isset($hoursData[$day]) && !empty($hoursData[$day])) {
                $germanDay = $germanDays[$day] ?? ucfirst($day);
                $formattedHours[] = "{$germanDay}: {$hoursData[$day]}";
            }
        }
        
        return implode(', ', $formattedHours) ?: 'Öffnungszeiten verfügbar';
    }
    
    /**
     * Check if a string is valid JSON
     */
    private function isJsonString($string) {
        if (!is_string($string)) return false;
        json_decode($string);
        return json_last_error() === JSON_ERROR_NONE;
    }
    
    /**
     * Get dynamic variables that depend on current context
     */
    private function getDynamicVariables($context = []) {
        $dynamicVars = [
            'current_date' => date('d.m.Y'),
            'current_time' => date('H:i'),
            'current_datetime' => date('d.m.Y H:i'),
            'current_year' => date('Y'),
            'current_month' => date('m'),
            'current_day' => date('d'),
            'server_name' => $_SERVER['HTTP_HOST'] ?? 'localhost',
            'request_time' => date('d.m.Y H:i:s'),
            'admin_url' => ($_SERVER['HTTP_HOST'] ?? 'localhost') . '/admin',
            'website_url' => ($_SERVER['HTTP_HOST'] ?? 'localhost')
        ];
        
        // Add context-specific variables
        if (isset($context['reference'])) {
            $dynamicVars['reference'] = $context['reference'];
        }
        if (isset($context['submission_id'])) {
            $dynamicVars['submission_id'] = $context['submission_id'];
        }
        
        return $dynamicVars;
    }
    
    /**
     * API endpoint to debug available variables
     */
    public function debugVariables() {
        try {
            $companyData = $this->getCompanyVariables();
            $dynamicData = $this->getDynamicVariables();
            
            // Also get a sample from settings table
            $allSettings = $this->queryAll("SELECT setting_key, setting_value FROM settings ORDER BY setting_key");
            
            return $this->success('Debug information', [
                'company_variables' => $companyData,
                'dynamic_variables' => $dynamicData,
                'all_database_settings' => $allSettings,
                'available_templates' => $this->queryAll("SELECT template_key, subject FROM email_templates WHERE is_active = 1"),
                'system_info' => [
                    'php_version' => PHP_VERSION,
                    'server_name' => $_SERVER['HTTP_HOST'] ?? 'unknown',
                    'current_time' => date('Y-m-d H:i:s'),
                    'database_file' => $this->_database ? 'Connected' : 'Not connected'
                ]
            ]);
            
        } catch (Exception $e) {
            return $this->error('Error getting debug information: ' . $e->getMessage());
        }
    }
    
    /**
     * Send actual email using template
     */
    public function sendTemplateEmail($templateKey, $toEmail, $variables = [], $attachments = []) {
        try {
            // Load template
            $template = $this->query("SELECT * FROM email_templates WHERE template_key = ? AND is_active = 1", [$templateKey]);
            if (!$template) {
                throw new Exception("Template not found: $templateKey");
            }
            
            // Get all variables
            $companyData = $this->getCompanyVariables();
            $dynamicData = $this->getDynamicVariables($variables);
            
            // Template variables
            $templateVars = [];
            if (!empty($template['variables'])) {
                $templateVars = json_decode($template['variables'], true) ?: [];
            }
            
            // Merge all variables
            $allVariables = array_merge($templateVars, $companyData, $dynamicData, $variables);
            
            // Process template
            $subject = $this->processTemplateString($template['subject'], $allVariables);
            $bodyHtml = $this->processTemplateString($template['body_html'], $allVariables);
            $bodyText = $this->processTemplateString($template['body_text'], $allVariables);
            
            // Setup email headers
            $headers = [
                'MIME-Version: 1.0',
                'Content-Type: text/html; charset=utf-8',
                'From: ' . $companyData['company_name'] . ' <' . $companyData['company_email'] . '>',
                'Reply-To: ' . $companyData['company_email'],
                'X-Mailer: DS-Allroundservice Email System'
            ];
            
            // Send email
            $success = mail($toEmail, $subject, $bodyHtml, implode("\r\n", $headers));
            
            if ($success) {
                // Log successful email
                $this->logEmailSent($templateKey, $toEmail, $subject, $allVariables);
                $this->debugLog("Email sent successfully to $toEmail using template $templateKey");
                return ['success' => true, 'message' => 'Email sent successfully'];
            } else {
                throw new Exception("Failed to send email");
            }
            
        } catch (Exception $e) {
            $this->debugLog("Error sending email: " . $e->getMessage());
            return ['success' => false, 'error' => $e->getMessage()];
        }
    }
    
    /**
     * Log sent emails for tracking
     */
    private function logEmailSent($templateKey, $toEmail, $subject, $variables) {
        try {
            $this->query(
                "INSERT INTO email_logs (template_key, recipient_email, subject, variables_used, sent_at, created_at) VALUES (?, ?, ?, ?, datetime('now'), datetime('now'))",
                [$templateKey, $toEmail, $subject, json_encode($variables)]
            );
        } catch (Exception $e) {
            $this->debugLog("Error logging email: " . $e->getMessage());
        }
    }
    
    /**
     * API endpoint to send test emails
     */
    public function sendTestEmail() {
        try {
            $input = json_decode(file_get_contents('php://input'), true);
            
            if (!isset($input['template_key']) || !isset($input['recipient_email'])) {
                return $this->error('Template key and recipient email are required');
            }
            
            $templateKey = $input['template_key'];
            $recipientEmail = $input['recipient_email'];
            $variables = $input['variables'] ?? [];
            
            $result = $this->sendTemplateEmail($templateKey, $recipientEmail, $variables);
            
            if ($result['success']) {
                return $this->success('Test email sent successfully');
            } else {
                return $this->error($result['error']);
            }
            
        } catch (Exception $e) {
            return $this->error('Error sending test email: ' . $e->getMessage());
        }
    }
    
    /**
     * Check what settings are actually in the database
     */
    private function checkDatabaseSettings() {
        try {
            $allSettings = $this->queryAll("SELECT setting_key, setting_value FROM settings ORDER BY setting_key");
            $settingsMap = [];
            foreach ($allSettings as $setting) {
                $settingsMap[$setting['setting_key']] = $setting['setting_value'];
            }
            return $settingsMap;
        } catch (Exception $e) {
            return ['error' => $e->getMessage()];
        }
    }
    
    // ========================================================================
    // E-Mail Inbox Management Methods
    // ========================================================================
    
    /**
     * Get emails from inbox
     */
    private function getInboxEmails() {
        error_log('📧 getInboxEmails() called - START');
        
        try {
            // Check if IMAP extension is loaded
            if (!extension_loaded('imap')) {
                error_log('❌ IMAP extension not loaded - returning error');
                return $this->error('IMAP-Erweiterung ist nicht installiert. Bitte installieren Sie php-imap.');
            }
            
            // Check permission
            if (!$this->hasPermission('email_inbox_view')) {
                error_log('❌ No permission for email inbox view - returning error');
                return $this->error('Keine Berechtigung für E-Mail-Posteingang');
            }
            
            $limit = (int)($_GET['limit'] ?? 20); // Reduziert von 50 auf 20
            $folder = $_GET['folder'] ?? 'INBOX';
            error_log("📂 Permission passed, loading emails: limit=$limit, folder=$folder");
            
            // Set time limit for email loading
            set_time_limit(120); // 2 minutes
            
            // Increase memory limit
            ini_set('memory_limit', '256M');
            
            try {
                $emailInbox = $this->getEmailInboxInstance();
                error_log('✅ EmailInbox instance created: ' . get_class($emailInbox));
            } catch (Exception $e) {
                error_log('❌ Error creating EmailInbox: ' . $e->getMessage());
                return $this->error('E-Mail-System-Initialisierung fehlgeschlagen: ' . $e->getMessage());
            } catch (Error $e) {
                error_log('❌ Fatal error creating EmailInbox: ' . $e->getMessage());
                return $this->error('E-Mail-System-Initialisierung fehlgeschlagen: ' . $e->getMessage());
            }
            
            try {
                error_log("🔄 Starting to load emails with Event Sourcing (limit: $limit, folder: $folder)");
                $emails = $emailInbox->getEmailsWithEventSourcing($limit, $folder);
                error_log("✅ Retrieved " . count($emails) . " emails via Event Sourcing");
                
                // Validate email data before proceeding
                if (!is_array($emails)) {
                    error_log("❌ getEmailsWithEventSourcing returned non-array: " . gettype($emails));
                    // Fallback to normal loading
                    error_log("🔄 Falling back to normal email loading...");
                    $emails = $emailInbox->getEmails($limit, $folder);
                    $eventStats = ['fallback' => true, 'reason' => 'non-array result'];
                } else {
                    // Test if emails can be JSON encoded
                    $testJson = json_encode($emails);
                    if ($testJson === false) {
                        error_log("❌ Email data cannot be JSON encoded: " . json_last_error_msg());
                        error_log("🔄 Falling back to normal email loading...");
                        $emails = $emailInbox->getEmails($limit, $folder);
                        $eventStats = ['fallback' => true, 'reason' => 'json_encoding_failed'];
                    } else {
                        // Get Event Store statistics
                        $eventStats = $emailInbox->getEventStoreStats();
                        error_log("📊 Event Store Stats: " . json_encode($eventStats));
                    }
                }
                
            } catch (Exception $e) {
                error_log('❌ Error getting emails with Event Sourcing: ' . $e->getMessage());
                error_log('🔄 Falling back to normal email loading...');
                
                try {
                    $emails = $emailInbox->getEmails($limit, $folder);
                    $eventStats = ['fallback' => true, 'fallback_reason' => $e->getMessage()];
                } catch (Exception $fallbackError) {
                    error_log('❌ Fallback also failed: ' . $fallbackError->getMessage());
                    return $this->error('Fehler beim Laden der E-Mails: ' . $fallbackError->getMessage());
                }
            } catch (Error $e) {
                error_log('❌ Fatal error getting emails with Event Sourcing: ' . $e->getMessage());
                error_log('🔄 Falling back to normal email loading...');
                
                try {
                    $emails = $emailInbox->getEmails($limit, $folder);
                    $eventStats = ['fallback' => true, 'fallback_reason' => $e->getMessage()];
                } catch (Exception $fallbackError) {
                    error_log('❌ Fallback also failed: ' . $fallbackError->getMessage());
                    return $this->error('Schwerwiegender Fehler beim Laden der E-Mails: ' . $fallbackError->getMessage());
                }
            }
            
            // Count unread emails - handle both 'unread' and 'seen' fields
            $unreadCount = count(array_filter($emails, function($email) {
                if (isset($email['unread'])) {
                    return $email['unread'];
                } elseif (isset($email['seen'])) {
                    return !$email['seen'];
                } else {
                    return false; // Default to read if neither field exists
                }
            }));
            
            // Sanitize email data to ensure JSON encoding works
            $sanitizedEmails = $this->sanitizeEmailsForJson($emails);
            
            return $this->success([
                'emails' => $sanitizedEmails,
                'total' => count($sanitizedEmails),
                'unread_count' => $unreadCount,
                'folder' => $folder,
                'event_stats' => $eventStats ?? [],
                'loading_method' => isset($eventStats['fallback']) ? 'fallback' : 'event_sourcing'
            ]);
            
        } catch (Exception $e) {
            error_log("❌ Error getting inbox emails: " . $e->getMessage());
            error_log("❌ Stack trace: " . $e->getTraceAsString());
            return $this->error('Fehler beim Laden der E-Mails: ' . $e->getMessage());
        }
    }
    
    /**
     * Sanitize email data to ensure it can be JSON encoded
     * Fixes UTF-8 encoding issues and removes problematic characters
     */
    private function sanitizeEmailsForJson($emails) {
        if (!is_array($emails)) {
            return $emails;
        }
        
        return array_map(function($email) {
            if (!is_array($email)) {
                return $email;
            }
            
            $sanitized = [];
            foreach ($email as $key => $value) {
                if (is_string($value)) {
                    // Ensure UTF-8 encoding
                    if (!mb_check_encoding($value, 'UTF-8')) {
                        $value = mb_convert_encoding($value, 'UTF-8', 'UTF-8');
                    }
                    // Remove any null bytes or invalid characters
                    $value = str_replace("\0", '', $value);
                    // Ensure valid UTF-8 by removing invalid sequences
                    $value = mb_convert_encoding($value, 'UTF-8', 'UTF-8');
                } elseif (is_array($value)) {
                    // Recursively sanitize nested arrays
                    $value = $this->sanitizeEmailsForJson([$value])[0];
                }
                $sanitized[$key] = $value;
            }
            return $sanitized;
        }, $emails);
    }
    
    /**
     * Get specific email details
     */
    private function getEmailDetails() {
        try {
            error_log("\n" . str_repeat('=', 80));
            error_log("📧 getEmailDetails() - START");
            error_log(str_repeat('=', 80));
            
            // Check permission
            if (!$this->hasPermission('email_inbox_view')) {
                error_log("❌ Permission denied for email_inbox_view");
                return $this->error('Keine Berechtigung für E-Mail-Details');
            }
            error_log("✅ Permission check passed");
            
            $emailId = (int)($_GET['id'] ?? 0);
            error_log("📥 Email ID from GET: " . var_export($_GET['id'] ?? 'NONE', true));
            error_log("🔢 Parsed Email ID: " . $emailId);
            
            if (!$emailId) {
                error_log("❌ No email ID provided");
                return $this->error('E-Mail-ID erforderlich');
            }
            
            error_log("📬 Creating EmailInbox instance...");
            $emailInbox = $this->getEmailInboxInstance();
            $inboxClass = get_class($emailInbox);
            error_log("✅ EmailInbox instance created: " . $inboxClass);
            
            error_log("🔍 Fetching email details for ID: " . $emailId);
            $email = $emailInbox->getEmailDetails($emailId);
            
            if (!$email) {
                error_log("❌ Email not found or getEmailDetails returned null");
                error_log("❌ EmailInbox class: " . $inboxClass);
                error_log("❌ Email ID: " . $emailId);
                return $this->error('E-Mail nicht gefunden');
            }
            
            error_log("✅ Email details retrieved successfully");
            error_log("📊 Email data keys: " . implode(', ', array_keys($email)));
            error_log("📧 Email subject: " . ($email['subject'] ?? 'N/A'));
            
            // 🔧 FIX: Load unread status from Event Store instead of IMAP
            // This ensures consistency with the email list (which loads from snapshots)
            try {
                // 🚀 PERFORMANCE: Get status from snapshot by loading only the metadata
                $snapshotStmt = $this->db->query("
                    SELECT snapshot_data 
                    FROM email_snapshots 
                    WHERE folder IN ('inbox', 'INBOX')
                    ORDER BY created_at DESC 
                    LIMIT 1
                ");
                $snapshot = $snapshotStmt->fetch(PDO::FETCH_ASSOC);
                
                if ($snapshot && !empty($snapshot['snapshot_data'])) {
                    $snapshotEmails = json_decode($snapshot['snapshot_data'], true);
                    if (is_array($snapshotEmails)) {
                        // Find the email in the snapshot
                        foreach ($snapshotEmails as $listEmail) {
                            if (isset($listEmail['id']) && $listEmail['id'] == $emailId) {
                                // Check for recent events that might have changed the status
                                $eventStmt = $this->db->prepare("
                                    SELECT event_type, event_data 
                                    FROM email_events 
                                    WHERE email_uid = :uid
                                    AND event_type IN ('email_read', 'email_unread')
                                    ORDER BY sequence_number DESC 
                                    LIMIT 1
                                ");
                                $eventStmt->execute([':uid' => $email['uid']]);
                                $recentEvent = $eventStmt->fetch(PDO::FETCH_ASSOC);
                                
                                if ($recentEvent) {
                                    // Use the most recent event status
                                    $email['unread'] = ($recentEvent['event_type'] === 'email_unread');
                                    $email['seen'] = !$email['unread'];
                                    error_log("🔄 Updated status from recent event: " . $recentEvent['event_type'] . " → unread=" . var_export($email['unread'], true));
                                } else {
                                    // Use snapshot status
                                    $email['unread'] = $listEmail['unread'] ?? false;
                                    $email['seen'] = $listEmail['seen'] ?? true;
                                    error_log("🔄 Updated status from snapshot: unread=" . var_export($email['unread'], true));
                                }
                                break;
                            }
                        }
                    }
                }
            } catch (Exception $e) {
                error_log("⚠️ Could not load status from EventStore: " . $e->getMessage());
                // Keep the IMAP status as fallback
            }
            
            // ⚡ FIX: Verify JSON encoding works before returning
            $testJson = json_encode($email);
            if ($testJson === false) {
                error_log("❌ JSON encoding failed: " . json_last_error_msg());
                error_log("⚠️ Attempting to clean email data...");
                
                // Try to clean the data
                $email = $this->cleanEmailDataForJson($email);
                
                // Test again
                $testJson = json_encode($email);
                if ($testJson === false) {
                    error_log("❌ JSON encoding still failed after cleaning");
                    return $this->error('JSON encoding error: ' . json_last_error_msg());
                }
                
                error_log("✅ JSON encoding successful after cleaning");
            }
            
            error_log(str_repeat('=', 80) . "\n");
            
            return $this->success([
                'email' => $email
            ]);
            
        } catch (Exception $e) {
            error_log("❌ Exception in getEmailDetails: " . $e->getMessage());
            error_log("❌ Stack trace: " . $e->getTraceAsString());
            error_log(str_repeat('=', 80) . "\n");
            return $this->error('Fehler beim Laden der E-Mail-Details: ' . $e->getMessage());
        }
    }
    
    /**
     * Mark email as read
     */
    private function markEmailAsRead() {
        error_log("\n" . str_repeat('=', 80));
        error_log("📧 markEmailAsRead() - START");
        error_log(str_repeat('=', 80));
        
        try {
            // Check permission
            if (!$this->hasPermission('email_inbox_manage')) {
                error_log("❌ Permission denied for email_inbox_manage");
                return $this->error('Keine Berechtigung für E-Mail-Verwaltung');
            }
            error_log("✅ Permission check passed");
            
            // Read raw input ONCE (important!)
            $rawInput = file_get_contents('php://input');
            error_log("📥 Raw Input: " . $rawInput);
            
            $input = json_decode($rawInput, true);
            error_log("� Parsed Input: " . json_encode($input, JSON_PRETTY_PRINT));
            
            $emailId = $input['id'] ?? '';
            error_log("🆔 Email ID extracted: '" . $emailId . "' (type: " . gettype($emailId) . ")");
            
            if (empty($emailId)) {
                error_log("❌ No email ID provided");
                return $this->error('E-Mail-ID erforderlich');
            }
            
            $emailInbox = $this->getEmailInboxInstance();
            $inboxClass = get_class($emailInbox);
            error_log("📬 EmailInbox instance: " . $inboxClass);
            
            // Log available methods
            $methods = get_class_methods($emailInbox);
            $markMethods = array_filter($methods, function($m) {
                return stripos($m, 'mark') !== false;
            });
            error_log("📋 Available mark* methods: " . implode(', ', $markMethods));
            
            // The frontend sends numeric IDs
            $success = false;
            
            if (is_numeric($emailId)) {
                error_log("🔢 Email ID is numeric: " . $emailId);
                
                // Try different methods based on what's available
                if (method_exists($emailInbox, 'markAsReadWithEvents')) {
                    error_log("🔄 Trying markAsReadWithEvents((int)$emailId)...");
                    $success = $emailInbox->markAsReadWithEvents((int)$emailId);
                    error_log("📊 markAsReadWithEvents result: " . ($success ? 'SUCCESS ✅' : 'FAILED ❌'));
                } elseif (method_exists($emailInbox, 'markAsRead')) {
                    error_log("🔄 Trying markAsRead((int)$emailId)...");
                    $success = $emailInbox->markAsRead((int)$emailId);
                    error_log("📊 markAsRead result: " . ($success ? 'SUCCESS ✅' : 'FAILED ❌'));
                }
                
                // If failed, try by UID
                if (!$success && method_exists($emailInbox, 'markAsReadByUID')) {
                    error_log("🔄 First attempt failed, trying markAsReadByUID('$emailId')...");
                    $success = $emailInbox->markAsReadByUID((string)$emailId);
                    error_log("📊 markAsReadByUID result: " . ($success ? 'SUCCESS ✅' : 'FAILED ❌'));
                }
            } else {
                error_log("🔤 Email ID is string: '" . $emailId . "'");
                
                if (method_exists($emailInbox, 'markAsReadByUID')) {
                    error_log("🔄 Trying markAsReadByUID('$emailId')...");
                    $success = $emailInbox->markAsReadByUID($emailId);
                    error_log("📊 markAsReadByUID result: " . ($success ? 'SUCCESS ✅' : 'FAILED ❌'));
                }
            }
            
            error_log("\n📊 FINAL RESULT: " . ($success ? 'SUCCESS ✅' : 'FAILED ❌'));
            error_log(str_repeat('=', 80) . "\n");
            
            if ($success) {
                return $this->success(['message' => 'E-Mail als gelesen markiert']);
            } else {
                return $this->error('Fehler beim Markieren der E-Mail');
            }
            
        } catch (Exception $e) {
            error_log("❌ EXCEPTION in markEmailAsRead: " . $e->getMessage());
            error_log("Stack trace: " . $e->getTraceAsString());
            error_log(str_repeat('=', 80) . "\n");
            return $this->error('Fehler beim Markieren der E-Mail: ' . $e->getMessage());
        }
    }
    
    /**
     * Mark email as unread
     */
    private function markEmailAsUnread() {
        error_log("\n" . str_repeat('=', 80));
        error_log("📧 markEmailAsUnread() - START");
        error_log(str_repeat('=', 80));
        
        try {
            // Check permission
            if (!$this->hasPermission('email_inbox_manage')) {
                error_log("❌ Permission denied for email_inbox_manage");
                return $this->error('Keine Berechtigung für E-Mail-Verwaltung');
            }
            error_log("✅ Permission check passed");
            
            // Read raw input ONCE (important!)
            $rawInput = file_get_contents('php://input');
            error_log("📥 Raw Input: " . $rawInput);
            
            $input = json_decode($rawInput, true);
            error_log("📦 Parsed Input: " . json_encode($input, JSON_PRETTY_PRINT));
            
            $emailId = $input['id'] ?? '';
            error_log("🆔 Email ID extracted: '" . $emailId . "' (type: " . gettype($emailId) . ")");
            
            if (empty($emailId)) {
                error_log("❌ No email ID provided");
                return $this->error('E-Mail-ID erforderlich');
            }
            
            $emailInbox = $this->getEmailInboxInstance();
            $inboxClass = get_class($emailInbox);
            error_log("📬 EmailInbox instance: " . $inboxClass);
            
            // Log available methods
            $methods = get_class_methods($emailInbox);
            $markMethods = array_filter($methods, function($m) {
                return stripos($m, 'mark') !== false;
            });
            error_log("📋 Available mark* methods: " . implode(', ', $markMethods));
            
            // The frontend sends numeric IDs
            $success = false;
            
            if (is_numeric($emailId)) {
                error_log("🔢 Email ID is numeric: " . $emailId);
                
                // Try different methods based on what's available
                if (method_exists($emailInbox, 'markAsUnreadWithEvents')) {
                    error_log("🔄 Trying markAsUnreadWithEvents((int)$emailId)...");
                    $success = $emailInbox->markAsUnreadWithEvents((int)$emailId);
                    error_log("📊 markAsUnreadWithEvents result: " . ($success ? 'SUCCESS ✅' : 'FAILED ❌'));
                } elseif (method_exists($emailInbox, 'markAsUnread')) {
                    error_log("🔄 Trying markAsUnread((int)$emailId)...");
                    $success = $emailInbox->markAsUnread((int)$emailId);
                    error_log("📊 markAsUnread result: " . ($success ? 'SUCCESS ✅' : 'FAILED ❌'));
                }
                
                // If failed, try by UID
                if (!$success && method_exists($emailInbox, 'markAsUnreadByUID')) {
                    error_log("🔄 First attempt failed, trying markAsUnreadByUID('$emailId')...");
                    $success = $emailInbox->markAsUnreadByUID((string)$emailId);
                    error_log("📊 markAsUnreadByUID result: " . ($success ? 'SUCCESS ✅' : 'FAILED ❌'));
                }
            } else {
                error_log("🔤 Email ID is string: '" . $emailId . "'");
                
                if (method_exists($emailInbox, 'markAsUnreadByUID')) {
                    error_log("🔄 Trying markAsUnreadByUID('$emailId')...");
                    $success = $emailInbox->markAsUnreadByUID($emailId);
                    error_log("📊 markAsUnreadByUID result: " . ($success ? 'SUCCESS ✅' : 'FAILED ❌'));
                }
            }
            
            error_log("\n📊 FINAL RESULT: " . ($success ? 'SUCCESS ✅' : 'FAILED ❌'));
            error_log(str_repeat('=', 80) . "\n");
            
            if ($success) {
                return $this->success(['message' => 'E-Mail als ungelesen markiert']);
            } else {
                return $this->error('Fehler beim Markieren der E-Mail');
            }
            
        } catch (Exception $e) {
            error_log("❌ EXCEPTION in markEmailAsUnread: " . $e->getMessage());
            error_log("Stack trace: " . $e->getTraceAsString());
            error_log(str_repeat('=', 80) . "\n");
            return $this->error('Fehler beim Markieren der E-Mail: ' . $e->getMessage());
        }
    }
    
    /**
     * Delete email
     */
    private function deleteEmail() {
        try {
            // Check permission
            if (!$this->hasPermission('email_inbox_manage')) {
                return $this->error('Keine Berechtigung für E-Mail-Löschung');
            }
            
            $input = json_decode(file_get_contents('php://input'), true);
            $emailId = (int)($input['id'] ?? 0);
            
            if (!$emailId) {
                return $this->error('E-Mail-ID erforderlich');
            }
            
            $emailInbox = $this->getEmailInboxInstance();
            
            // Use Event Sourcing method
            $success = $emailInbox->deleteEmailWithEvents($emailId);
            
            if ($success) {
                return $this->success(['message' => 'E-Mail gelöscht (Event Sourcing)']);
            } else {
                return $this->error('Fehler beim Löschen der E-Mail');
            }
            
        } catch (Exception $e) {
            error_log("Error deleting email: " . $e->getMessage());
            return $this->error('Fehler beim Löschen der E-Mail: ' . $e->getMessage());
        }
    }
    
    /**
     * Download email attachment
     */
    private function downloadAttachment() {
        error_log("\n" . str_repeat('=', 80));
        error_log("📎 downloadAttachment() - START");
        error_log(str_repeat('=', 80));
        
        // Clear ALL output buffers immediately
        while (ob_get_level() > 0) {
            ob_end_clean();
        }
        
        // Remove any previously set headers
        if (!headers_sent()) {
            header_remove();
        }
        
        try {
            // Check permission
            if (!$this->hasPermission('email_inbox_view')) {
                error_log("❌ Permission denied for email_inbox_view");
                http_response_code(403);
                die('Keine Berechtigung für E-Mail-Anhänge');
            }
            error_log("✅ Permission check passed");
            
            // Get parameters
            $emailUid = $_GET['email_uid'] ?? $_GET['uid'] ?? '';
            $attachmentIndex = (int)($_GET['attachment_index'] ?? $_GET['index'] ?? -1);
            
            error_log("📧 Email UID: " . $emailUid);
            error_log("📎 Attachment Index: " . $attachmentIndex);
            
            if (empty($emailUid)) {
                error_log("❌ No email UID provided");
                http_response_code(400);
                die('E-Mail-UID erforderlich');
            }
            
            if ($attachmentIndex < 0) {
                error_log("❌ Invalid attachment index");
                http_response_code(400);
                die('Anhang-Index erforderlich');
            }
            
            $emailInbox = $this->getEmailInboxInstance();
            error_log("✅ EmailInbox instance created: " . get_class($emailInbox));
            
            // Get attachment
            error_log("🔄 Fetching attachment...");
            $attachment = $emailInbox->getAttachment($emailUid, $attachmentIndex);
            
            if (!$attachment) {
                error_log("❌ Attachment not found");
                http_response_code(404);
                die('Anhang nicht gefunden');
            }
            
            error_log("✅ Attachment found:");
            error_log("  - Filename: " . ($attachment['filename'] ?? 'unknown'));
            error_log("  - Size: " . ($attachment['size'] ?? 0) . " bytes");
            error_log("  - MIME Type: " . ($attachment['mime_type'] ?? 'unknown'));
            
            // Prepare file data
            $filename = $attachment['filename'] ?? 'attachment';
            $mimeType = $attachment['mime_type'] ?? 'application/octet-stream';
            $content = $attachment['content'] ?? '';
            $fileSize = strlen($content);
            
            // Sanitize filename for header (remove quotes and special chars)
            $safeFilename = str_replace(['"', "\n", "\r"], '', $filename);
            
            error_log("📤 Sending file headers:");
            error_log("  - Content-Type: " . $mimeType);
            error_log("  - Filename: " . $safeFilename);
            error_log("  - Size: " . $fileSize . " bytes");
            
            // Set headers for download - MUST be done before any output
            header('Content-Type: ' . $mimeType);
            header('Content-Disposition: attachment; filename="' . $safeFilename . '"');
            header('Content-Length: ' . $fileSize);
            header('Content-Transfer-Encoding: binary');
            header('Cache-Control: must-revalidate, post-check=0, pre-check=0');
            header('Pragma: public');
            header('Expires: 0');
            
            // Disable compression for binary data
            if (function_exists('apache_setenv')) {
                @apache_setenv('no-gzip', '1');
            }
            @ini_set('zlib.output_compression', 'Off');
            
            // Output file content
            echo $content;
            flush();
            
            error_log("✅ Attachment sent successfully - " . $fileSize . " bytes");
            error_log(str_repeat('=', 80) . "\n");
            
            exit; // Important: Stop script execution after download
            
        } catch (Exception $e) {
            error_log("❌ EXCEPTION in downloadAttachment: " . $e->getMessage());
            error_log("Stack trace: " . $e->getTraceAsString());
            error_log(str_repeat('=', 80) . "\n");
            
            // Clear buffers again in case of error
            while (ob_get_level() > 0) {
                ob_end_clean();
            }
            
            http_response_code(500);
            die('Fehler beim Herunterladen des Anhangs: ' . $e->getMessage());
        }
    }
    
    /**
     * Test email connection
     */
    private function testEmailConnection() {
        error_log('🔌 testEmailConnection() called');
        
        try {
            // Check if IMAP extension is loaded
            if (!extension_loaded('imap')) {
                error_log('❌ IMAP extension not loaded');
                return $this->error('IMAP-Erweiterung ist nicht installiert. Bitte installieren Sie php-imap.');
            }
            
            // Check permission
            if (!$this->hasPermission('settings_manage')) {
                error_log('❌ No permission for email settings');
                return $this->error('Keine Berechtigung für E-Mail-Einstellungen');
            }
            
            try {
                if (extension_loaded('imap') && class_exists('EmailInbox')) {
                    $emailInbox = $this->getEmailInboxInstance();
                    error_log('✅ EmailInbox instance created for test');
                } else {
                    $emailInbox = $this->getEmailInboxInstance();
                    error_log('⚠️ Using EmailInboxFallback for test');
                }
            } catch (Exception $e) {
                error_log('❌ Error creating EmailInbox for test: ' . $e->getMessage());
                return $this->error('E-Mail-System-Initialisierung fehlgeschlagen: ' . $e->getMessage());
            }
            
            $result = $emailInbox->testConnection();
            error_log('📊 Connection test result: ' . json_encode($result));
            
            return $this->success($result);
            
        } catch (Exception $e) {
            error_log("Error testing email connection: " . $e->getMessage());
            return $this->error('Verbindungstest fehlgeschlagen: ' . $e->getMessage());
        }
    }
    
    /**
     * Get unread email count
     */
    private function getEmailUnreadCount() {
        try {
            // Check permission
            if (!$this->hasPermission('email_inbox_view')) {
                return $this->error('Keine Berechtigung für E-Mail-Posteingang');
            }
            
            $emailInbox = $this->getEmailInboxInstance();
            
            $count = $emailInbox->getUnreadCount();
            
            return $this->success([
                'unread_count' => $count
            ]);
            
        } catch (Exception $e) {
            error_log("Error getting unread count: " . $e->getMessage());
            return $this->error('Fehler beim Abrufen der ungelesenen E-Mails: ' . $e->getMessage());
        }
    }
    
    // ========================================================================
    // Event Store Management Methods
    // ========================================================================
    
    /**
     * Create manual email snapshot
     */
    private function createEmailSnapshot() {
        try {
            // Check permission
            if (!$this->hasPermission('email_inbox_manage')) {
                return $this->error('Keine Berechtigung für E-Mail-Verwaltung');
            }
            
            $emailInbox = $this->getEmailInboxInstance();
            
            $success = $emailInbox->createSnapshot();
            
            if ($success) {
                return $this->success(['message' => 'E-Mail-Snapshot erfolgreich erstellt']);
            } else {
                return $this->error('Fehler beim Erstellen des Snapshots');
            }
            
        } catch (Exception $e) {
            error_log("Error creating email snapshot: " . $e->getMessage());
            return $this->error('Fehler beim Erstellen des Snapshots: ' . $e->getMessage());
        }
    }
    
    /**
     * Get Event Store statistics
     */
    private function getEventStoreStats() {
        try {
            // Check permission
            if (!$this->hasPermission('email_inbox_view')) {
                return $this->error('Keine Berechtigung für E-Mail-Statistiken');
            }
            
            $emailInbox = $this->getEmailInboxInstance();
            
            $stats = $emailInbox->getEventStoreStats();
            
            return $this->success([
                'stats' => $stats,
                'message' => 'Event Store-Statistiken abgerufen'
            ]);
            
        } catch (Exception $e) {
            error_log("Error getting event store stats: " . $e->getMessage());
            return $this->error('Fehler beim Abrufen der Event Store-Statistiken: ' . $e->getMessage());
        }
    }
    
    /**
     * Cleanup old events and snapshots
     */
    private function cleanupEventStore() {
        try {
            // Check permission
            if (!$this->hasPermission('email_inbox_manage')) {
                return $this->error('Keine Berechtigung für E-Mail-Verwaltung');
            }
            
            $input = json_decode(file_get_contents('php://input'), true);
            $daysToKeep = (int)($input['days_to_keep'] ?? 30);
            $snapshotsToKeep = (int)($input['snapshots_to_keep'] ?? 5);
            
            $emailInbox = $this->getEmailInboxInstance();
            
            $result = $emailInbox->cleanupEventStore($daysToKeep, $snapshotsToKeep);
            
            return $this->success([
                'result' => $result,
                'message' => "Event Store bereinigt: {$result['events_deleted']} Events und {$result['snapshots_deleted']} Snapshots gelöscht"
            ]);
            
        } catch (Exception $e) {
            error_log("Error cleaning up event store: " . $e->getMessage());
            return $this->error('Fehler beim Bereinigen des Event Stores: ' . $e->getMessage());
        }
    }
    
    /**
     * Debug email structure
     */
    private function debugEmailStructure() {
        try {
            $emailInbox = $this->getEmailInboxInstance();
            $emails = $emailInbox->getEmailsWithEventSourcing(5); // Get only 5 emails for debugging
            
            $debugInfo = [];
            foreach ($emails as $email) {
                $debugInfo[] = [
                    'id' => $email['id'] ?? 'NO_ID',
                    'uid' => $email['uid'] ?? 'NO_UID', 
                    'message_number' => $email['message_number'] ?? 'NO_MSG_NUM',
                    'unread' => $email['unread'] ?? 'NO_UNREAD_FIELD',
                    'seen' => $email['seen'] ?? 'NO_SEEN_FIELD',
                    'subject' => substr($email['subject'] ?? 'NO_SUBJECT', 0, 50),
                    'all_keys' => array_keys($email)
                ];
            }
            
            return $this->success([
                'message' => 'Debug info for email structure',
                'emails_count' => count($emails),
                'sample_emails' => $debugInfo
            ]);
            
        } catch (Exception $e) {
            return $this->error('Debug failed: ' . $e->getMessage());
        }
    }
    
    // ========================================================================
    // LOGS MANAGEMENT (Admin only)
    // ========================================================================
    
    /**
     * Get activity logs with filtering, sorting, and pagination
     */
    private function getActivityLogs() {
        error_log("📊 getActivityLogs() called");
        
        // Check admin permission
        if (!$this->hasPermission('logs_view')) {
            error_log("❌ Permission denied for logs_view");
            return $this->error('Zugriff verweigert. Nur Administratoren können auf Logs zugreifen.');
        }
        
        error_log("✅ Permission granted, loading activity logs");
        
        $page = (int)($_GET['page'] ?? 1);
        $limit = min((int)($_GET['limit'] ?? 50), 100); // Max 100
        $sortField = $_GET['sort'] ?? 'created_at';
        $sortDirection = $_GET['direction'] ?? 'desc';
        $offset = ($page - 1) * $limit;
        
        error_log("📄 Page: $page, Limit: $limit, Sort: $sortField $sortDirection");
        
        // Build WHERE clause
        $where = [];
        $params = [];
        
        if (!empty($_GET['search'])) {
            $where[] = "(ual.action LIKE :search OR ual.details LIKE :search OR u.username LIKE :search)";
            $params[':search'] = '%' . $_GET['search'] . '%';
        }
        
        if (isset($_GET['user']) && $_GET['user'] !== '') {
            if ($_GET['user'] == '0') {
                // Filter for System entries (user_id is NULL or 0)
                $where[] = "(ual.user_id IS NULL OR ual.user_id = 0)";
            } else {
                $where[] = "ual.user_id = :user_id";
                $params[':user_id'] = $_GET['user'];
            }
        }
        
        // Note: Using 'log_action' instead of 'action' to avoid conflict with API action parameter
        if (!empty($_GET['log_action'])) {
            $where[] = "ual.action = :log_action";
            $params[':log_action'] = $_GET['log_action'];
        }
        
        if (!empty($_GET['date'])) {
            $where[] = "DATE(ual.created_at) = :date";
            $params[':date'] = $_GET['date'];
        }
        
        $whereClause = !empty($where) ? 'WHERE ' . implode(' AND ', $where) : '';
        
        // Validate sort field
        $allowedSortFields = ['created_at', 'user_id', 'action', 'ip_address'];
        if (!in_array($sortField, $allowedSortFields)) {
            $sortField = 'created_at';
        }
        
        $sortDirection = strtoupper($sortDirection) === 'ASC' ? 'ASC' : 'DESC';
        
        try {
            // Get total count
            $countSql = "SELECT COUNT(*) as total FROM user_activity_log ual 
                         LEFT JOIN users u ON ual.user_id = u.id 
                         $whereClause";
            error_log("🔍 Count SQL: $countSql");
            error_log("🔍 Params: " . print_r($params, true));
            $countStmt = $this->db->prepare($countSql);
            $countStmt->execute($params);
            $totalRecords = $countStmt->fetch()['total'];
            error_log("📊 Total records found: $totalRecords");
            
            // Get logs
            $sql = "SELECT ual.*, u.username 
                    FROM user_activity_log ual 
                    LEFT JOIN users u ON ual.user_id = u.id 
                    $whereClause 
                    ORDER BY ual.$sortField $sortDirection 
                    LIMIT :limit OFFSET :offset";
            
            error_log("🔍 Query SQL: $sql");
            error_log("🔍 Limit: $limit, Offset: $offset");
            
            $stmt = $this->db->prepare($sql);
            foreach ($params as $key => $value) {
                $stmt->bindValue($key, $value);
            }
            $stmt->bindValue(':limit', $limit, PDO::PARAM_INT);
            $stmt->bindValue(':offset', $offset, PDO::PARAM_INT);
            $stmt->execute();
            
            $logs = $stmt->fetchAll();
            
            error_log("📝 Found " . count($logs) . " activity logs");
            
            // Rename created_at to timestamp for frontend compatibility
            foreach ($logs as &$log) {
                $log['timestamp'] = $log['created_at'];
            }
            
            error_log("✅ Returning success response with " . count($logs) . " logs");
            
            return $this->success([
                'logs' => $logs,
                'pagination' => [
                    'current_page' => $page,
                    'total_pages' => ceil($totalRecords / $limit),
                    'total_records' => $totalRecords,
                    'per_page' => $limit
                ]
            ]);
        } catch (PDOException $e) {
            error_log("Error in getActivityLogs: " . $e->getMessage());
            return $this->error('Fehler beim Laden der Activity Logs');
        }
    }
    
    /**
     * Get user sessions logs with filtering, sorting, and pagination
     */
    private function getSessionsLogs() {
        // Check admin permission
        if (!$this->hasPermission('logs_view')) {
            return $this->error('Zugriff verweigert. Nur Administratoren können auf Logs zugreifen.');
        }
        
        $page = (int)($_GET['page'] ?? 1);
        $limit = min((int)($_GET['limit'] ?? 50), 100);
        $sortField = $_GET['sort'] ?? 'created_at';
        $sortDirection = $_GET['direction'] ?? 'desc';
        $offset = ($page - 1) * $limit;
        
        // Build WHERE clause
        $where = [];
        $params = [];
        
        if (!empty($_GET['search'])) {
            $where[] = "(u.username LIKE :search OR us.ip_address LIKE :search)";
            $params[':search'] = '%' . $_GET['search'] . '%';
        }
        
        if (isset($_GET['user']) && $_GET['user'] !== '') {
            if ($_GET['user'] == '0') {
                // Filter for System entries (user_id is NULL or 0)
                $where[] = "(us.user_id IS NULL OR us.user_id = 0)";
            } else {
                $where[] = "us.user_id = :user_id";
                $params[':user_id'] = $_GET['user'];
            }
        }
        
        if (!empty($_GET['status'])) {
            if ($_GET['status'] === 'active') {
                $where[] = "us.is_active = 1 AND us.expires_at > datetime('now')";
            } elseif ($_GET['status'] === 'expired') {
                $where[] = "us.expires_at <= datetime('now')";
            } elseif ($_GET['status'] === 'logged_out') {
                $where[] = "us.is_active = 0";
            }
        }
        
        if (!empty($_GET['date'])) {
            $where[] = "DATE(us.created_at) = :date";
            $params[':date'] = $_GET['date'];
        }
        
        $whereClause = !empty($where) ? 'WHERE ' . implode(' AND ', $where) : '';
        
        // Validate sort field
        $allowedSortFields = ['created_at', 'user_id', 'ip_address', 'expires_at'];
        if (!in_array($sortField, $allowedSortFields)) {
            $sortField = 'created_at';
        }
        
        $sortDirection = strtoupper($sortDirection) === 'ASC' ? 'ASC' : 'DESC';
        
        try {
            // Get total count
            $countSql = "SELECT COUNT(*) as total FROM user_sessions us 
                         LEFT JOIN users u ON us.user_id = u.id 
                         $whereClause";
            $countStmt = $this->db->prepare($countSql);
            $countStmt->execute($params);
            $totalRecords = $countStmt->fetch()['total'];
            
            // Get sessions
            $sql = "SELECT us.*, u.username,
                    CASE 
                        WHEN us.is_active = 0 THEN 'logged_out'
                        WHEN us.expires_at <= datetime('now') THEN 'expired'
                        ELSE 'active'
                    END as status
                    FROM user_sessions us 
                    LEFT JOIN users u ON us.user_id = u.id 
                    $whereClause 
                    ORDER BY us.$sortField $sortDirection 
                    LIMIT :limit OFFSET :offset";
            
            $stmt = $this->db->prepare($sql);
            foreach ($params as $key => $value) {
                $stmt->bindValue($key, $value);
            }
            $stmt->bindValue(':limit', $limit, PDO::PARAM_INT);
            $stmt->bindValue(':offset', $offset, PDO::PARAM_INT);
            $stmt->execute();
            
            $sessions = $stmt->fetchAll();
            
            // Add session_id and last_activity for frontend compatibility
            foreach ($sessions as &$session) {
                $session['session_id'] = $session['session_token'];
                $session['last_activity'] = $session['created_at']; // Fallback
            }
            
            return $this->success([
                'logs' => $sessions,
                'pagination' => [
                    'current_page' => $page,
                    'total_pages' => ceil($totalRecords / $limit),
                    'total_records' => $totalRecords,
                    'per_page' => $limit
                ]
            ]);
        } catch (PDOException $e) {
            error_log("Error in getSessionsLogs: " . $e->getMessage());
            return $this->error('Fehler beim Laden der Sessions Logs');
        }
    }
    
    /**
     * Get email logs with filtering, sorting, and pagination
     */
    private function getEmailLogs() {
        // Check admin permission
        if (!$this->hasPermission('logs_view')) {
            return $this->error('Zugriff verweigert. Nur Administratoren können auf Logs zugreifen.');
        }
        
        $page = (int)($_GET['page'] ?? 1);
        $limit = min((int)($_GET['limit'] ?? 50), 100);
        $sortField = $_GET['sort'] ?? 'created_at';
        $sortDirection = $_GET['direction'] ?? 'desc';
        $offset = ($page - 1) * $limit;
        
        // Build WHERE clause
        $where = [];
        $params = [];
        
        if (!empty($_GET['search'])) {
            $where[] = "(el.recipient_email LIKE :search OR el.subject LIKE :search)";
            $params[':search'] = '%' . $_GET['search'] . '%';
        }
        
        if (!empty($_GET['status'])) {
            $where[] = "el.status = :status";
            $params[':status'] = $_GET['status'];
        }
        
        if (!empty($_GET['type'])) {
            $where[] = "el.template_key = :type";
            $params[':type'] = $_GET['type'];
        }
        
        if (!empty($_GET['date'])) {
            $where[] = "DATE(el.created_at) = :date";
            $params[':date'] = $_GET['date'];
        }
        
        $whereClause = !empty($where) ? 'WHERE ' . implode(' AND ', $where) : '';
        
        // Validate sort field
        $allowedSortFields = ['created_at', 'recipient_email', 'subject', 'template_key', 'status', 'sent_at'];
        if (!in_array($sortField, $allowedSortFields)) {
            $sortField = 'created_at';
        }
        
        $sortDirection = strtoupper($sortDirection) === 'ASC' ? 'ASC' : 'DESC';
        
        try {
            // Get total count
            $countSql = "SELECT COUNT(*) as total FROM email_logs el $whereClause";
            $countStmt = $this->db->prepare($countSql);
            $countStmt->execute($params);
            $totalRecords = $countStmt->fetch()['total'];
            
            // Get emails
            $sql = "SELECT el.* 
                    FROM email_logs el 
                    $whereClause 
                    ORDER BY el.$sortField $sortDirection 
                    LIMIT :limit OFFSET :offset";
            
            $stmt = $this->db->prepare($sql);
            foreach ($params as $key => $value) {
                $stmt->bindValue($key, $value);
            }
            $stmt->bindValue(':limit', $limit, PDO::PARAM_INT);
            $stmt->bindValue(':offset', $offset, PDO::PARAM_INT);
            $stmt->execute();
            
            $emails = $stmt->fetchAll();
            
            // Map database fields to frontend expectations
            foreach ($emails as &$email) {
                $email['timestamp'] = $email['sent_at'] ?? $email['created_at'];
                $email['recipient'] = $email['recipient_email'];
                $email['type'] = $email['template_key'];
            }
            
            return $this->success([
                'logs' => $emails,
                'pagination' => [
                    'current_page' => $page,
                    'total_pages' => ceil($totalRecords / $limit),
                    'total_records' => $totalRecords,
                    'per_page' => $limit
                ]
            ]);
        } catch (PDOException $e) {
            error_log("Error in getEmailLogs: " . $e->getMessage());
            return $this->error('Fehler beim Laden der Email Logs');
        }
    }
    
    /**
     * Export activity logs to CSV
     */
    private function exportActivityLogs() {
        // Check admin permission
        if (!$this->hasPermission('logs_view')) {
            http_response_code(403);
            echo "Zugriff verweigert";
            exit;
        }
        
        // Build WHERE clause (same as getActivityLogs)
        $where = [];
        $params = [];
        
        if (!empty($_GET['search'])) {
            $where[] = "(ual.action LIKE :search OR ual.details LIKE :search OR u.username LIKE :search)";
            $params[':search'] = '%' . $_GET['search'] . '%';
        }
        
        if (!empty($_GET['user'])) {
            $where[] = "ual.user_id = :user_id";
            $params[':user_id'] = $_GET['user'];
        }
        
        if (!empty($_GET['action'])) {
            $where[] = "ual.action = :action";
            $params[':action'] = $_GET['action'];
        }
        
        if (!empty($_GET['date'])) {
            $where[] = "DATE(ual.created_at) = :date";
            $params[':date'] = $_GET['date'];
        }
        
        $whereClause = !empty($where) ? 'WHERE ' . implode(' AND ', $where) : '';
        
        try {
            $sql = "SELECT ual.created_at, u.username, ual.action, ual.details, ual.ip_address, ual.success
                    FROM user_activity_log ual 
                    LEFT JOIN users u ON ual.user_id = u.id 
                    $whereClause 
                    ORDER BY ual.created_at DESC";
            
            $stmt = $this->db->prepare($sql);
            $stmt->execute($params);
            $logs = $stmt->fetchAll();
            
            header('Content-Type: text/csv; charset=utf-8');
            header('Content-Disposition: attachment; filename="activity-logs-' . date('Y-m-d') . '.csv"');
            
            $output = fopen('php://output', 'w');
            fputcsv($output, ['Zeitstempel', 'Benutzer', 'Aktion', 'Details', 'IP-Adresse', 'Erfolg']);
            
            foreach ($logs as $log) {
                fputcsv($output, [
                    $log['created_at'],
                    $log['username'] ?? 'System',
                    $log['action'],
                    $log['details'],
                    $log['ip_address'],
                    $log['success'] ? 'Ja' : 'Nein'
                ]);
            }
            
            fclose($output);
            exit;
        } catch (PDOException $e) {
            error_log("Error in exportActivityLogs: " . $e->getMessage());
            http_response_code(500);
            echo "Exportfehler";
            exit;
        }
    }
    
    /**
     * Export sessions logs to CSV
     */
    private function exportSessionsLogs() {
        // Check admin permission
        if (!$this->hasPermission('logs_view')) {
            http_response_code(403);
            echo "Zugriff verweigert";
            exit;
        }
        
        try {
            $sql = "SELECT us.created_at, u.username, us.ip_address, us.expires_at, 
                    CASE 
                        WHEN us.is_active = 0 THEN 'Abgemeldet'
                        WHEN us.expires_at <= datetime('now') THEN 'Abgelaufen'
                        ELSE 'Aktiv'
                    END as status
                    FROM user_sessions us 
                    LEFT JOIN users u ON us.user_id = u.id 
                    ORDER BY us.created_at DESC";
            
            $stmt = $this->db->prepare($sql);
            $stmt->execute();
            $sessions = $stmt->fetchAll();
            
            header('Content-Type: text/csv; charset=utf-8');
            header('Content-Disposition: attachment; filename="sessions-logs-' . date('Y-m-d') . '.csv"');
            
            $output = fopen('php://output', 'w');
            fputcsv($output, ['Erstellt', 'Benutzer', 'IP-Adresse', 'Läuft ab', 'Status']);
            
            foreach ($sessions as $session) {
                fputcsv($output, [
                    $session['created_at'],
                    $session['username'] ?? 'Unbekannt',
                    $session['ip_address'],
                    $session['expires_at'],
                    $session['status']
                ]);
            }
            
            fclose($output);
            exit;
        } catch (PDOException $e) {
            error_log("Error in exportSessionsLogs: " . $e->getMessage());
            http_response_code(500);
            echo "Exportfehler";
            exit;
        }
    }
    
    /**
     * Export email logs to CSV
     */
    private function exportEmailLogs() {
        // Check admin permission
        if (!$this->hasPermission('logs_view')) {
            http_response_code(403);
            echo "Zugriff verweigert";
            exit;
        }
        
        try {
            $sql = "SELECT created_at, recipient_email, subject, template_key, status, error_message, sent_at
                    FROM email_logs 
                    ORDER BY created_at DESC";
            
            $stmt = $this->db->prepare($sql);
            $stmt->execute();
            $emails = $stmt->fetchAll();
            
            header('Content-Type: text/csv; charset=utf-8');
            header('Content-Disposition: attachment; filename="email-logs-' . date('Y-m-d') . '.csv"');
            
            $output = fopen('php://output', 'w');
            fputcsv($output, ['Erstellt', 'Empfänger', 'Betreff', 'Template', 'Status', 'Fehler', 'Gesendet']);
            
            foreach ($emails as $email) {
                fputcsv($output, [
                    $email['created_at'],
                    $email['recipient_email'],
                    $email['subject'],
                    $email['template_key'],
                    $email['status'],
                    $email['error_message'],
                    $email['sent_at']
                ]);
            }
            
            fclose($output);
            exit;
        } catch (PDOException $e) {
            error_log("Error in exportEmailLogs: " . $e->getMessage());
            http_response_code(500);
            echo "Exportfehler";
            exit;
        }
    }
    
    /**
     * Terminate a user session (Admin only)
     */
    private function terminateSession() {
        // Check admin permission
        if (!$this->hasPermission('logs_view')) {
            return $this->error('Zugriff verweigert');
        }
        
        $data = json_decode(file_get_contents('php://input'), true);
        $sessionId = $data['session_id'] ?? '';
        
        if (empty($sessionId)) {
            return $this->error('Sitzungs-ID fehlt');
        }
        
        try {
            // Update session status
            $stmt = $this->db->prepare("UPDATE user_sessions SET is_active = 0 WHERE session_token = :session_id");
            $stmt->execute([':session_id' => $sessionId]);
            
            if ($stmt->rowCount() > 0) {
                return $this->success([
                    'message' => 'Sitzung erfolgreich beendet'
                ]);
            } else {
                return $this->error('Sitzung nicht gefunden');
            }
        } catch (PDOException $e) {
            error_log("Error in terminateSession: " . $e->getMessage());
            return $this->error('Fehler beim Beenden der Sitzung');
        }
    }
    
    /**
     * Debug method to check permissions and log data
     */
    private function debugPermissions() {
        $debugData = [
            'session' => [
                'authenticated' => $_SESSION['authenticated'] ?? null,
                'user_id' => $_SESSION['user_id'] ?? null,
                'username' => $_SESSION['username'] ?? null,
                'role' => $_SESSION['role'] ?? null
            ],
            'database_check' => []
        ];
        
        try {
            // Get user from database
            if (isset($_SESSION['user_id'])) {
                $stmt = $this->db->prepare("SELECT id, username, role FROM users WHERE id = ?");
                $stmt->execute([$_SESSION['user_id']]);
                $user = $stmt->fetch(PDO::FETCH_ASSOC);
                $debugData['user'] = $user;
                
                if ($user) {
                    // Check logs_view permission
                    $stmt = $this->db->prepare("
                        SELECT * FROM user_permissions 
                        WHERE role = ? AND permission_key = ?
                    ");
                    $stmt->execute([$user['role'], 'logs_view']);
                    $permission = $stmt->fetch(PDO::FETCH_ASSOC);
                    
                    $debugData['logs_view_permission'] = $permission;
                    $debugData['has_logs_view'] = $this->hasPermission('logs_view');
                    
                    // Get all permissions for this role
                    $stmt = $this->db->prepare("SELECT * FROM user_permissions WHERE role = ? ORDER BY permission_key");
                    $stmt->execute([$user['role']]);
                    $debugData['all_permissions'] = $stmt->fetchAll(PDO::FETCH_ASSOC);
                }
            }
            
            // Check if log tables exist and have data
            $stmt = $this->db->query("SELECT COUNT(*) FROM user_activity_log");
            $debugData['activity_log_count'] = $stmt->fetchColumn();
            
            $stmt = $this->db->query("SELECT COUNT(*) FROM user_sessions");
            $debugData['sessions_count'] = $stmt->fetchColumn();
            
            $stmt = $this->db->query("SELECT COUNT(*) FROM email_logs");
            $debugData['email_logs_count'] = $stmt->fetchColumn();
            
        } catch (PDOException $e) {
            $debugData['error'] = $e->getMessage();
        }
        
        return $this->success($debugData);
    }
    
    /**
     * Get list of users for filtering in logs
     */
    private function getUsersList() {
        error_log("📋 getUsersList() called");
        
        // Check admin permission (same as logs)
        if (!$this->hasPermission('logs_view')) {
            error_log("❌ Permission denied for logs_view");
            return $this->error('Zugriff verweigert.');
        }
        
        try {
            $users = $this->queryAll(
                "SELECT id, username, role 
                 FROM users 
                 WHERE is_active = 1 
                 ORDER BY username ASC"
            );
            
            // Add "System" as a virtual user at the beginning
            array_unshift($users, [
                'id' => '0',
                'username' => 'System',
                'role' => 'System'
            ]);
            
            error_log("✅ Found " . count($users) . " users (including System)");
            
            return $this->success([
                'users' => $users
            ]);
        } catch (PDOException $e) {
            error_log("Error in getUsersList: " . $e->getMessage());
            return $this->error('Fehler beim Laden der Benutzerliste');
        }
    }
}

// Handle the request
try {
    // Clear any output that might have been generated by includes
    if (ob_get_length()) {
        ob_clean();
    }
    
    error_log("Creating AdminAPI instance...");
    $api = new AdminAPI();
    error_log("Calling handleRequest...");
    $result = $api->handleRequest();
    error_log("handleRequest returned: " . (is_array($result) ? json_encode($result) : print_r($result, true)));
    
    // Ensure we have a valid result
    if ($result === null || $result === false) {
        error_log("⚠️ WARNING: handleRequest returned null or false");
        $result = ['success' => false, 'error' => 'No response from handler'];
    }
    
    // Discard any remaining buffered output and turn off buffering
    $discarded = ob_get_clean();
    if ($discarded) {
        error_log("⚠️ Discarded buffered content: " . substr($discarded, 0, 200));
    }
    
    // Send JSON response
    $jsonResponse = json_encode($result, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE);
    if ($jsonResponse === false) {
        $jsonError = json_last_error_msg();
        error_log("❌ JSON encoding failed: " . $jsonError);
        error_log("❌ Data type: " . gettype($result));
        error_log("❌ Data keys: " . (is_array($result) ? implode(', ', array_keys($result)) : 'N/A'));
        
        // Try to identify the problematic data
        if (is_array($result) && isset($result['emails'])) {
            error_log("❌ Number of emails: " . count($result['emails']));
            
            // Try encoding without emails to see if that's the issue
            $testResult = $result;
            unset($testResult['emails']);
            $testJson = json_encode($testResult);
            if ($testJson === false) {
                error_log("❌ Even without emails, encoding fails: " . json_last_error_msg());
            } else {
                error_log("⚠️ Encoding works without emails - issue is in email data");
                
                // Try to find which email is problematic
                foreach ($result['emails'] as $index => $email) {
                    if (json_encode($email) === false) {
                        error_log("❌ Email at index $index fails encoding: " . json_last_error_msg());
                        error_log("❌ Problematic email keys: " . implode(', ', array_keys($email)));
                        break;
                    }
                }
            }
        }
        
        // Send simplified error response
        echo json_encode(['success' => false, 'error' => 'JSON encoding error: ' . $jsonError]);
    } else {
        echo $jsonResponse;
        error_log("✅ JSON response sent successfully (" . strlen($jsonResponse) . " bytes)");
    }
} catch (Exception $e) {
    // Clean buffer on error
    if (ob_get_length()) {
        ob_end_clean();
    }
    error_log("❌ Exception in admin.php: " . $e->getMessage());
    error_log("Exception trace: " . $e->getTraceAsString());
    echo json_encode([
        'success' => false,
        'error' => 'API Error: ' . $e->getMessage()
    ], JSON_PRETTY_PRINT);
}
